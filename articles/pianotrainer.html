<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Piano Trainer</title>
    <style>
    /* General Styles */
    body {
        font-family: Arial, sans-serif;
        background-color: #f0f0f0;
    }

    #game-container {
        text-align: center;
        margin: 20px auto;
        width: 90%;
        max-width: 1200px; /* Increased max-width to accommodate side-by-side layout */
        background-color: #fff;
        padding: 20px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        border-radius: 8px;
    }

    /* Top Section: Piano and Instructions */
    #top-section {
        display: flex;
        justify-content: center;
        align-items: flex-start;
        gap: 20px;
    }

    /* Piano Styles */
    #piano {
        position: relative;
        width: 600px; /* Adjusted width after removing two keys */
        height: 200px;
    }

    .white-key, .black-key {
        position: absolute;
        border: 1px solid #000;
        border-radius: 0 0 5px 5px;
        cursor: pointer;
        user-select: none;
        display: flex;
        align-items: flex-end;
        justify-content: center;
        padding-bottom: 5px;
        font-size: 14px;
        color: #000;
    }

    .white-key {
        width: 50px;
        height: 200px;
        background: white;
        z-index: 1;
    }

    .black-key {
        width: 30px;
        height: 120px;
        background: black;
        color: white;
        z-index: 2;
    }

    /* Positioning White Keys */
    .white-key:nth-child(1) { left: 0px; }
    .white-key:nth-child(3) { left: 50px; }
    .white-key:nth-child(5) { left: 100px; }
    .white-key:nth-child(6) { left: 150px; }
    .white-key:nth-child(8) { left: 200px; }
    .white-key:nth-child(10) { left: 250px; }
    .white-key:nth-child(12) { left: 300px; }

    /* Positioning Black Keys */
    .black-key:nth-child(2) { left: 35px; }
    .black-key:nth-child(4) { left: 85px; }
    .black-key:nth-child(7) { left: 185px; }
    .black-key:nth-child(9) { left: 235px; }
    .black-key:nth-child(11) { left: 285px; }

    /* Highlighting Keys */
    .white-key.active {
        background: #ffd700;
    }

    .black-key.active {
        background: #ff8c00;
    }

    /* Feedback Display */
    #feedback {
        width: 800px;
        height: 50px;
        margin: 20px auto;
        transition: background-color 0.5s;
        border: 1px solid #ccc;
        border-radius: 5px;
    }

    /* Mode Buttons */
    #mode-buttons button {
        margin: 5px;
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
    }

    /* Waveform Selection */
    #waveform-selection {
        margin: 20px auto;
    }

    #waveform-selection label {
        margin-right: 10px;
        font-size: 16px;
    }

    #waveform-selection select {
        padding: 5px;
        font-size: 16px;
    }

    /* Metronome Controls */
    #metronome-controls {
        margin: 20px auto;
    }

    #metronome-controls h3 {
        margin-bottom: 10px;
    }

    #metronome-controls button {
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
    }

    #metronome-controls input {
        width: 60px;
        padding: 5px;
        font-size: 16px;
        margin-left: 10px;
    }

    /* Chord Settings */
    #chord-settings {
        margin: 20px auto;
    }

    #chord-settings h3 {
        margin-bottom: 10px;
    }

    #chord-settings select {
        padding: 5px;
        font-size: 16px;
        margin-right: 10px;
    }

    /* Staff Canvas */
    #staff {
        margin-top: 20px;
        border: 1px solid #ccc;
        border-radius: 5px;
    }

    /* MIDI Controls */
    #midi-controls {
        margin: 20px auto;
    }

    #midi-controls label {
        margin-right: 10px;
        font-size: 16px;
    }

    #midi-controls select {
        padding: 5px;
        font-size: 16px;
    }

    /* Instructions Box */
    #instructions {
        width: 400px; /* Adjusted width to fit beside piano */
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
        background-color: #fafafa;
        text-align: left;
    }

    #instructions p {
        margin: 0;
        font-size: 16px;
    }

    /* Note Range Selection */
    #note-range-selection {
        margin: 20px auto;
    }

    #note-range-selection label {
        margin-right: 10px;
        font-size: 16px;
    }

    #note-range-selection select {
        padding: 5px;
        font-size: 16px;
        margin-right: 20px;
    }

    </style>
    <!-- Include VexFlow Library -->
    <script src="https://unpkg.com/vexflow/releases/vexflow-min.js"></script>
</head>
<body>
    <div id="game-container">
        <!-- Top Section: Piano and Instructions -->
        <div id="top-section">
            <!-- Piano Keyboard -->
            <div id="piano">
                <!-- White Keys -->
                <div class="white-key" data-note="C4">A</div>
                <div class="black-key" data-note="C#4">W</div>
                <div class="white-key" data-note="D4">S</div>
                <div class="black-key" data-note="D#4">E</div>
                <div class="white-key" data-note="E4">D</div>
                <div class="white-key" data-note="F4">F</div>
                <div class="black-key" data-note="F#4">T</div>
                <div class="white-key" data-note="G4">G</div>
                <div class="black-key" data-note="G#4">Y</div>
                <div class="white-key" data-note="A4">H</div>
                <div class="black-key" data-note="A#4">U</div>
                <div class="white-key" data-note="B4">J</div>
            </div>

            <!-- Instructions -->
            <div id="instructions">
                <p><strong>Instructions:</strong></p>
                <p>
                    - Use the keyboard or a MIDI controller to play notes.<br>
                    - Press <strong>'x'</strong> to shift all notes down by one octave.<br>
                    - Press <strong>'c'</strong> to shift all notes up by one octave.<br>
                    - Use the "Low Note" and "High Note" dropdowns to set the note range.<br>
                </p>
            </div>
        </div>

        <!-- Note Range Selection -->
        <div id="note-range-selection">
            <label for="low-note">Low Note:</label>
            <select id="low-note"></select>

            <label for="high-note">High Note:</label>
            <select id="high-note"></select>
        </div>

        <!-- Feedback Display -->
        <div id="feedback"></div>

        <!-- Mode Buttons -->
        <div id="mode-buttons">
            <button onclick="setMode('treble')">Treble Clef Mode</button>
            <button onclick="setMode('bass')">Bass Clef Mode</button>
            <button onclick="setMode('ear')">Ear Training Mode</button>
        </div>

        <!-- Waveform Selection -->
        <div id="waveform-selection">
            <label for="waveform">Select Waveform:</label>
            <select id="waveform" onchange="setWaveform(this.value)">
                <option value="sine">Sine</option>
                <option value="square">Square</option>
                <option value="triangle">Triangle</option>
                <option value="sawtooth">Sawtooth</option>
            </select>
        </div>

        <!-- Metronome Controls -->
        <div id="metronome-controls">
            <h3>Metronome</h3>
            <button onclick="toggleMetronome()">
                <span id="metronome-status">Start</span>
            </button>
            <label for="bpm">BPM:</label>
            <input type="number" id="bpm" value="120" min="40" max="240" onchange="setBPM(this.value)">
        </div>

        <!-- Chord Settings -->
        <div id="chord-settings">
            <h3>Chord Settings</h3>
            <label for="chord-size">Number of Notes:</label>
            <select id="chord-size" onchange="setChordSize(this.value)">
                <option value="1">Single Note</option>
                <option value="2">2 Notes</option>
                <option value="3">3 Notes</option>
                <option value="4">4 Notes</option>
                <option value="5">5 Notes</option>
            </select>
        </div>

        <!-- MIDI Controller Selection -->
        <div id="midi-controls">
            <label for="midi-select">MIDI Controller:</label>
            <select id="midi-select">
                <option value="keyboard">Keyboard</option>
                <!-- MIDI devices will be populated here -->
            </select>
        </div>

        <!-- Staff Canvas -->
        <canvas id="staff" width="800" height="200"></canvas>
    </div>

    <script>
    // ====================
    // Piano Trainer Script
    // ====================

    // Key Mappings
    const keyMappings = {
        'a': 'C4',
        'w': 'C#4',
        's': 'D4',
        'e': 'D#4',
        'd': 'E4',
        'f': 'F4',
        't': 'F#4',
        'g': 'G4',
        'y': 'G#4',
        'h': 'A4',
        'u': 'A#4',
        'j': 'B4'
    };

    // Reverse Mapping for Piano Keys
    const noteToKey = {
        'C4': 'a',
        'C#4': 'w',
        'Db4': 'w', // Added flat equivalent
        'D4': 's',
        'D#4': 'e',
        'Eb4': 'e', // Added flat equivalent
        'E4': 'd',
        'F4': 'f',
        'F#4': 't',
        'Gb4': 't', // Added flat equivalent
        'G4': 'g',
        'G#4': 'y',
        'Ab4': 'y', // Added flat equivalent
        'A4': 'h',
        'A#4': 'u',
        'Bb4': 'u', // Added flat equivalent
        'B4': 'j'
    };

    // Initialize Audio Context (Declared Only Once)
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    // Variables
    let currentMode = null;          // 'treble', 'bass', 'ear'
    let targetNoteQueue = [];        // Queue of target notes or chords
    let waveform = 'sine';           // Default waveform
    let metronomeInterval = null;
    let bpm = 120;                   // Default BPM
    let chordSize = 1;               // Default chord size
    let requiredNotes = new Set();   // Notes required for current chord input
    let currentOctaveShift = 0;      // 0: No shift, -1: Down, +1: Up

    // MIDI Variables
    let midiAccess = null;
    let midiInput = null;

    // Define all possible notes from C3 to B5
    const allNotes = [
        'C3', 'C#3', 'Db3', 'D3', 'D#3', 'Eb3', 'E3', 'F3', 'F#3', 'Gb3',
        'G3', 'G#3', 'Ab3', 'A3', 'A#3', 'Bb3', 'B3',
        'C4', 'C#4', 'Db4', 'D4', 'D#4', 'Eb4', 'E4', 'F4', 'F#4', 'Gb4',
        'G4', 'G#4', 'Ab4', 'A4', 'A#4', 'Bb4', 'B4',
        'C5', 'C#5', 'Db5', 'D5', 'D#5', 'Eb5', 'E5', 'F5', 'F#5', 'Gb5',
        'G5', 'G#5', 'Ab5', 'A5', 'A#5', 'Bb5', 'B5'
    ];
    const QUEUE_LENGTH = 8;           // Desired queue length

    // Note Frequencies
    const noteFrequencies = {
        'C3': 130.81,
        'C#3': 138.59,
        'Db3': 138.59,
        'D3': 146.83,
        'D#3': 155.56,
        'Eb3': 155.56,
        'E3': 164.81,
        'F3': 174.61,
        'F#3': 185.00,
        'Gb3': 185.00,
        'G3': 196.00,
        'G#3': 207.65,
        'Ab3': 207.65,
        'A3': 220.00,
        'A#3': 233.08,
        'Bb3': 233.08,
        'B3': 246.94,
        'C4': 261.63,
        'C#4': 277.18,
        'Db4': 277.18,
        'D4': 293.66,
        'D#4': 311.13,
        'Eb4': 311.13,
        'E4': 329.63,
        'F4': 349.23,
        'F#4': 369.99,
        'Gb4': 369.99,
        'G4': 392.00,
        'G#4': 415.30,
        'Ab4': 415.30,
        'A4': 440.00,
        'A#4': 466.16,
        'Bb4': 466.16,
        'B4': 493.88,
        'C5': 523.25,
        'C#5': 554.37,
        'Db5': 554.37,
        'D5': 587.33,
        'D#5': 622.25,
        'Eb5': 622.25,
        'E5': 659.25,
        'F5': 698.46,
        'F#5': 739.99,
        'Gb5': 739.99,
        'G5': 783.99,
        'G#5': 830.61,
        'Ab5': 830.61,
        'A5': 880.00,
        'A#5': 932.33,
        'Bb5': 932.33,
        'B5': 987.77
    };

    // Normalize Note (Map Flats to Sharps for frequency and logic)
    function normalizeNote(note) {
        const flatToSharpMap = {
            'Db3': 'C#3',
            'Eb3': 'D#3',
            'Gb3': 'F#3',
            'Ab3': 'G#3',
            'Bb3': 'A#3',
            'Db4': 'C#4',
            'Eb4': 'D#4',
            'Gb4': 'F#4',
            'Ab4': 'G#4',
            'Bb4': 'A#4',
            'Db5': 'C#5',
            'Eb5': 'D#5',
            'Gb5': 'F#5',
            'Ab5': 'G#5',
            'Bb5': 'A#5'
        };
        return flatToSharpMap[note] || note;
    }

    // Initialize Note Queue with 8 Notes or Chords
    function initializeNoteQueue() {
        targetNoteQueue = [];
        for (let i = 0; i < QUEUE_LENGTH; i++) {
            if (chordSize === 1) {
                targetNoteQueue.push(getRandomNote());
            } else {
                const chord = getRandomChord(chordSize);
                if (chord.length === chordSize) { // Ensure full chord size
                    targetNoteQueue.push(chord);
                } else {
                    // If unable to generate full chord, fallback to single notes
                    targetNoteQueue.push(getRandomNote());
                }
            }
        }
        drawStaff();
        // Optionally, play the first note or chord to indicate the start
        if (currentMode === 'ear') {
            playEarTrainingNote();
        }
    }

    // Handle User Input
    function handleUserInput(note) {
        if (targetNoteQueue.length === 0) return;

        const currentTarget = targetNoteQueue[0];
        if (Array.isArray(currentTarget)) {
            // Chord Input
            requiredNotes.add(note);
            highlightKey(note);
            const normalizedTarget = currentTarget.map(normalizeNote);
            const normalizedUser = Array.from(requiredNotes).map(normalizeNote);

            // Check if all required notes are pressed
            const isCorrect = currentTarget.every(targetNote => normalizedUser.includes(normalizeNote(targetNote)));
            if (isCorrect) {
                showFeedback('correct');
                // Remove the first chord
                targetNoteQueue.shift();
                // Add a new chord at the end
                targetNoteQueue.push(getRandomChord(chordSize));
                // Update the staff display
                drawStaff();
                // Reset required notes
                requiredNotes.clear();
                // If in ear training mode, play the next note or chord
                if (currentMode === 'ear') {
                    setTimeout(() => {playEarTrainingNote();}, 500);
                }
            } else {
                // Not all required notes pressed yet
                // Optionally, provide partial feedback or do nothing
            }
        } else {
            // Single Note Input
            const normalizedTargetNote = normalizeNote(currentTarget);
            const normalizedUserNote = normalizeNote(note);

            const delayDuration = 500;

            if (normalizedUserNote === normalizedTargetNote) {
                showFeedback('correct');
                // Remove the first note
                targetNoteQueue.shift();
                // Add a new note at the end
                targetNoteQueue.push(getRandomNote());
                // Update the staff display
                drawStaff();
                // If in ear training mode, play the next note
                if (currentMode === 'ear') {
                    setTimeout(() => {playEarTrainingNote();}, delayDuration)
                }
            } else {
                showFeedback('incorrect');
            }
        }
    }

    // Set Game Mode
    function setMode(mode) {
        currentMode = mode;
        initializeNoteQueue();
    }

    // Get Random Single Note within the selected range with Octave Shift and Flats
    function getRandomNote() {
        const availableNotes = getNotesInRange(lowNote, highNote);
        if (availableNotes.length === 0) return null;

        const randomIndex = Math.floor(Math.random() * availableNotes.length);
        let note = availableNotes[randomIndex];

        // Apply octave shift
        note = applyOctaveShift(note);

        return note;
    }

    // Get Random Chord of specified size within the selected range with notes at least 2 half-steps apart
    function getRandomChord(size) {
        const availableNotes = getNotesInRange(lowNote, highNote);
        if (availableNotes.length === 0) return [];

        // Sort availableNotes based on frequency to facilitate semitone difference
        const sortedNotes = availableNotes.slice().sort((a, b) => noteFrequencies[a] - noteFrequencies[b]);

        const chord = [];
        const usedIndices = new Set();

        for (let attempt = 0; attempt < 100; attempt++) { // Limit attempts to prevent infinite loops
            chord.length = 0;
            usedIndices.clear();

            while (chord.length < size) {
                const randIdx = Math.floor(Math.random() * sortedNotes.length);
                if (usedIndices.has(randIdx)) continue;

                const candidateNote = sortedNotes[randIdx];

                // Check semitone difference with existing chord notes
                let isValid = true;
                for (let existingNote of chord) {
                    const diff = getSemitoneDifference(existingNote, candidateNote);
                    if (diff < 2) {
                        isValid = false;
                        break;
                    }
                }

                if (isValid) {
                    chord.push(candidateNote);
                    usedIndices.add(randIdx);
                }

                if (usedIndices.size === sortedNotes.length) break;
            }

            if (chord.length === size) break;
        }

        return chord;
    }

    // Helper Function to Get Notes within the selected range
    function getNotesInRange(low, high) {
        const lowIndex = allNotes.indexOf(low);
        const highIndex = allNotes.indexOf(high);

        if (lowIndex === -1 || highIndex === -1 || lowIndex > highIndex) {
            return [];
        }

        return allNotes.slice(lowIndex, highIndex + 1);
    }

    // Helper Function to Apply Octave Shift
    function applyOctaveShift(note) {
        let shiftedNote = note;
        if (note.length === 3) { // e.g., C#4
            const noteName = note.slice(0, -1);
            let octave = parseInt(note.slice(-1)) + currentOctaveShift;
            // Ensure octave stays within 3 to 5
            octave = Math.min(Math.max(octave, 3), 5);
            shiftedNote = noteName + octave;
        } else if (note.length === 2) { // e.g., C4
            const noteName = note.slice(0, -1);
            let octave = parseInt(note.slice(-1)) + currentOctaveShift;
            // Ensure octave stays within 3 to 5
            octave = Math.min(Math.max(octave, 3), 5);
            shiftedNote = noteName + octave;
        }
        return shiftedNote;
    }

    // Helper Function to Calculate Semitone Difference
    function getSemitoneDifference(note1, note2) {
        const noteOrder = [
            'C3', 'C#3', 'Db3', 'D3', 'D#3', 'Eb3', 'E3', 'F3', 'F#3', 'Gb3',
            'G3', 'G#3', 'Ab3', 'A3', 'A#3', 'Bb3', 'B3',
            'C4', 'C#4', 'Db4', 'D4', 'D#4', 'Eb4', 'E4', 'F4', 'F#4', 'Gb4',
            'G4', 'G#4', 'Ab4', 'A4', 'A#4', 'Bb4', 'B4',
            'C5', 'C#5', 'Db5', 'D5', 'D#5', 'Eb5', 'E5', 'F5', 'F#5', 'Gb5',
            'G5', 'G#5', 'Ab5', 'A5', 'A#5', 'Bb5', 'B5'
        ];
        const index1 = noteOrder.indexOf(note1);
        const index2 = noteOrder.indexOf(note2);
        return Math.abs(index1 - index2);
    }

    // Convert Note to VexFlow Key Format
    function noteToVexflowKey(note) {
        // Use regex to parse the note into name, accidental, and octave
        const regex = /^([A-Ga-g])([#b]?)(\d)$/;
        const match = note.match(regex);
        if (match) {
            const noteName = match[1].toLowerCase();
            const accidental = match[2];
            const octave = match[3];
            return {
                key: noteName + '/' + octave,
                accidental: accidental
            };
        } else {
            console.error('Invalid note format:', note);
            return { key: 'c/4', accidental: null };
        }
    }

    // Draw Staff with Note Queue
    function drawStaff() {
        const canvas = document.getElementById('staff');
        const renderer = new Vex.Flow.Renderer(canvas, Vex.Flow.Renderer.Backends.CANVAS);
        const context = renderer.getContext();
        context.clearRect(0, 0, canvas.width, canvas.height);

        // Create a single stave
        const stave = new Vex.Flow.Stave(10, 40, 700);
        stave.addClef(currentMode === 'bass' ? 'bass' : 'treble');
        stave.setContext(context).draw();

        // Prepare StaveNotes
        const vfNotes = targetNoteQueue.map(item => {
            if (Array.isArray(item)) {
                // Chord - Sort the notes in ascending order based on frequency
                const sortedItem = item.slice().sort((a, b) => noteFrequencies[a] - noteFrequencies[b]);

                const keys = sortedItem.map(note => {
                    const noteData = noteToVexflowKey(note);
                    return noteData.key;
                });

                const staveNote = new Vex.Flow.StaveNote({ 
                    clef: currentMode === 'bass' ? 'bass' : 'treble', 
                    keys: keys, 
                    duration: "q" 
                });

                // Add accidentals if necessary
                sortedItem.forEach((note, index) => {
                    const noteData = noteToVexflowKey(note);
                    if (noteData.accidental) {
                        staveNote.addAccidental(index, new Vex.Flow.Accidental(noteData.accidental));
                    }
                });

                return staveNote;
            } else {
                // Single Note
                const noteData = noteToVexflowKey(item);
                const staveNote = new Vex.Flow.StaveNote({ 
                    clef: currentMode === 'bass' ? 'bass' : 'treble', 
                    keys: [noteData.key], 
                    duration: "q" 
                });
                if (noteData.accidental) {
                    staveNote.addAccidental(0, new Vex.Flow.Accidental(noteData.accidental));
                }
                return staveNote;
            }
        });

        // Create a single voice with all quarter notes
        const voice = new Vex.Flow.Voice({
            num_beats: QUEUE_LENGTH, // 8 beats
            beat_value: 4,           // Quarter note
            resolution: Vex.Flow.RESOLUTION
        });

        voice.addTickables(vfNotes);

        // Create a formatter and format the voice
        const formatter = new Vex.Flow.Formatter()
            .joinVoices([voice])
            .format([voice], 680); // Slightly less than stave width to accommodate measure lines

        // Draw the voice
        voice.draw(context, stave);

        // Draw measure lines after every 4 notes (every 4 beats)
        const measureInterval = 4; // Every 4 beats
        const staveStartX = stave.getX();
        const staveWidth = stave.getWidth();
        const noteSpacing = staveWidth / QUEUE_LENGTH;
        for (let i = 1; i < QUEUE_LENGTH / measureInterval; i++) {
            const x = staveStartX + (i * measureInterval * noteSpacing);
            context.beginPath();
            context.moveTo(x, stave.getYForLine(0) - 20); // Adjust vertical position as needed
            context.lineTo(x, stave.getYForLine(4) + 20); // Adjust vertical position as needed
            context.strokeStyle = '#000';
            context.lineWidth = 1;
            context.stroke();
        }
    }

    // Play Ear Training Note or Chord
    function playEarTrainingNote() {
        if (targetNoteQueue.length === 0) return;
        const currentTarget = targetNoteQueue[0];
        if (Array.isArray(currentTarget)) {
            playNotes(currentTarget);
        } else {
            playNote(currentTarget);
        }
    }

    // Show Feedback
    function showFeedback(status) {
        const feedback = document.getElementById('feedback');
        if (status === 'correct') {
            feedback.style.backgroundColor = 'green';
        } else if (status === 'incorrect') {
            feedback.style.backgroundColor = 'red';
        }
        setTimeout(() => {
            feedback.style.backgroundColor = 'transparent';
        }, 500);
    }

    // Set Waveform
    function setWaveform(wave) {
        waveform = wave;
    }

    // ====================
    // Piano Keyboard Visual
    // ====================

    // Function to highlight key
    function highlightKey(note) {
        const keyElement = document.querySelector(`[data-note="${note}"]`);
        if (keyElement) {
            keyElement.classList.add('active');
            setTimeout(() => {
                keyElement.classList.remove('active');
            }, 300);
        }
    }

    // Event Listeners for Piano Clicks
    document.querySelectorAll('.white-key, .black-key').forEach(key => {
        key.addEventListener('mousedown', () => {
            const baseNote = key.getAttribute('data-note');
            let note = baseNote;

            // Apply octave shift
            if (baseNote.length === 3) { // e.g., C#4
                const noteName = baseNote.slice(0, -1);
                let octave = parseInt(baseNote.slice(-1)) + currentOctaveShift;
                // Ensure octave stays within 3 to 5
                const finalOctave = Math.min(Math.max(octave, 3), 5);
                note = noteName + finalOctave;
            } else if (baseNote.length === 2) { // e.g., C4
                const noteName = baseNote.slice(0, -1);
                let octave = parseInt(baseNote.slice(-1)) + currentOctaveShift;
                // Ensure octave stays within 3 to 5
                const finalOctave = Math.min(Math.max(octave, 3), 5);
                note = noteName + finalOctave;
            }

            playNote(note);
            handleUserInput(note);
            highlightKey(note);
        });
    });

    // ====================
    // Metronome Functionality
    // ====================

    // Toggle Metronome On/Off
    function toggleMetronome() {
        if (metronomeInterval) {
            clearInterval(metronomeInterval);
            metronomeInterval = null;
            document.getElementById('metronome-status').innerText = 'Start';
        } else {
            startMetronome();
            document.getElementById('metronome-status').innerText = 'Stop';
        }
    }

    // Start Metronome
    function startMetronome() {
        const interval = (60 / bpm) * 1000; // BPM to milliseconds
        metronomeInterval = setInterval(() => {
            playMetronomeTick();
        }, interval);
    }

    // Play Metronome Tick
    function playMetronomeTick() {
        const oscillator = audioContext.createOscillator();
        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(1000, audioContext.currentTime); // High pitch tick

        const envelope = audioContext.createGain();
        envelope.gain.setValueAtTime(0, audioContext.currentTime);
        envelope.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.001);
        envelope.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

        oscillator.connect(envelope);
        envelope.connect(audioContext.destination);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.2);
    }

    // Set BPM
    function setBPM(value) {
        bpm = parseInt(value);
        if (metronomeInterval) {
            clearInterval(metronomeInterval);
            startMetronome();
        }
    }

    // ====================
    // Chord Settings Functionality
    // ====================

    // Set Chord Size
    function setChordSize(value) {
        chordSize = parseInt(value);
        if (chordSize < 1) chordSize = 1;
        if (chordSize > 5) chordSize = 5; // Limit to 5 notes
        initializeNoteQueue();
    }

    // ====================
    // MIDI Support Functionality
    // ====================

    // Initialize MIDI
    function initMIDI() {
        if (navigator.requestMIDIAccess) {
            navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);
        } else {
            alert("Web MIDI API is not supported in this browser.");
        }
    }

    // Handle MIDI Access Success
    function onMIDISuccess(midi) {
        midiAccess = midi;
        listInputs(midiAccess);
        midiAccess.onstatechange = () => {
            listInputs(midiAccess);
        };
    }

    // Handle MIDI Access Failure
    function onMIDIFailure() {
        alert("Could not access your MIDI devices.");
    }

    // List MIDI Inputs and Populate Dropdown
    function listInputs(midiAccess) {
        const midiSelect = document.getElementById('midi-select');
        const selectedValue = midiSelect.value;
        // Remove all options except 'Keyboard'
        while (midiSelect.options.length > 1) {
            midiSelect.remove(1);
        }

        const inputs = midiAccess.inputs.values();
        for (let input of inputs) {
            const option = document.createElement('option');
            option.value = input.id;
            option.text = input.name;
            midiSelect.appendChild(option);
        }

        // If previously selected MIDI controller is disconnected, reset to Keyboard
        if (selectedValue !== 'keyboard') {
            const existingOption = Array.from(midiSelect.options).find(option => option.value === selectedValue);
            if (!existingOption) {
                midiSelect.value = 'keyboard';
                disableMIDI();
            }
        }
    }

    // Handle MIDI Selection Change
    document.getElementById('midi-select').addEventListener('change', function() {
        if (this.value === 'keyboard') {
            disableMIDI();
            enableKeyboard();
        } else {
            const selectedInput = midiAccess.inputs.get(this.value);
            if (selectedInput) {
                enableMIDI(selectedInput);
                disableKeyboard();
            }
        }
    });

    // Enable MIDI Input
    function enableMIDI(input) {
        midiInput = input;
        midiInput.onmidimessage = handleMIDIMessage;
    }

    // Disable MIDI Input
    function disableMIDI() {
        if (midiInput) {
            midiInput.onmidimessage = null;
            midiInput = null;
        }
    }

    // Enable Keyboard Input
    function enableKeyboard() {
        // No additional actions needed since keyboard listeners are always active
    }

    // Disable Keyboard Input
    function disableKeyboard() {
        // Optionally, remove keyboard listeners if you want to disable them
        // For now, we'll keep them active as per user request
    }

    // Handle MIDI Messages
    function handleMIDIMessage(message) {
        const [status, noteNumber, velocity] = message.data;
        const command = status & 0xF0;
        const channel = status & 0x0F;

        if (command === 0x90 && velocity > 0) { // Note on
            const noteName = midiNoteNumberToNoteName(noteNumber);
            if (noteName) {
                playNote(noteName);
                handleUserInput(noteName);
                highlightKey(noteName);
            }
        }
        // Note off (0x80) can be handled if needed
    }

    // Convert MIDI Note Number to Note Name
    function midiNoteNumberToNoteName(noteNumber) {
        const octave = Math.floor(noteNumber / 12) - 1;
        const noteIndex = noteNumber % 12;
        const sharpNoteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const flatNoteNames = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];

        // Determine if current chord uses sharps or flats
        let accidentalType = 'sharp';
        if (targetNoteQueue.length > 0 && Array.isArray(targetNoteQueue[0])) {
            const firstNote = targetNoteQueue[0][0];
            accidentalType = firstNote.includes('b') ? 'flat' : 'sharp';
        }

        const noteName = accidentalType === 'sharp' ? sharpNoteNames[noteIndex] : flatNoteNames[noteIndex];
        let fullNote = noteName + octave;

        // Apply octave shift
        let shiftedOctave = octave + currentOctaveShift;

        // Ensure octave stays within 3 to 5
        shiftedOctave = Math.min(Math.max(shiftedOctave, 3), 5);
        fullNote = noteName + shiftedOctave;

        // If the note is a sharp, randomly choose to display it as sharp or flat
        if (noteName.includes('#')) {
            if (Math.random() < 0.5) {
                // Convert to flat equivalent
                const sharpToFlatMap = {
                    'C#': 'Db',
                    'D#': 'Eb',
                    'F#': 'Gb',
                    'G#': 'Ab',
                    'A#': 'Bb'
                };
                const flatNote = sharpToFlatMap[noteName] + shiftedOctave;
                return flatNote;
            }
        }

        return fullNote;
    }

    // Initialize Note Range Dropdowns
    function initializeNoteRangeDropdowns() {
        const lowNoteSelect = document.getElementById('low-note');
        const highNoteSelect = document.getElementById('high-note');

        // Populate the dropdowns with allNotes, removing duplicates (e.g., Db3 is same as C#3)
        const uniqueNotes = allNotes.filter((note, index, self) => self.indexOf(note) === index);

        uniqueNotes.forEach(note => {
            const option1 = document.createElement('option');
            option1.value = note;
            option1.text = note;
            lowNoteSelect.appendChild(option1);

            const option2 = document.createElement('option');
            option2.value = note;
            option2.text = note;
            highNoteSelect.appendChild(option2);
        });

        // Set default selections
        lowNote = 'C3';
        highNote = 'B5';

        lowNoteSelect.value = lowNote;
        highNoteSelect.value = highNote;

        // Add event listeners
        lowNoteSelect.addEventListener('change', () => {
            const selectedLow = lowNoteSelect.value;
            const selectedHigh = highNoteSelect.value;
            if (allNotes.indexOf(selectedLow) > allNotes.indexOf(selectedHigh)) {
                alert("Low Note cannot be higher than High Note.");
                lowNoteSelect.value = lowNote;
            } else {
                lowNote = selectedLow;
                initializeNoteQueue();
            }
        });

        highNoteSelect.addEventListener('change', () => {
            const selectedLow = lowNoteSelect.value;
            const selectedHigh = highNoteSelect.value;
            if (allNotes.indexOf(selectedLow) > allNotes.indexOf(selectedHigh)) {
                alert("High Note cannot be lower than Low Note.");
                highNoteSelect.value = highNote;
            } else {
                highNote = selectedHigh;
                initializeNoteQueue();
            }
        });
    }

    // Set Waveform
    function setWaveform(wave) {
        waveform = wave;
    }

    // ====================
    // Initialize Note Range and MIDI on Page Load
    // ====================

    window.addEventListener('load', () => {
        initializeNoteRangeDropdowns();
        initMIDI();
        initializeNoteQueue();
    });

    // ====================
    // Keyboard Event Handling with Debouncing and Octave Shift
    // ====================

    const pressedKeys = {};

    document.addEventListener('keydown', (event) => {
        const key = event.key.toLowerCase();

        // Handle octave shifting
        if (key === 'x') {
            currentOctaveShift = -1;
            return;
        }
        if (key === 'c') {
            currentOctaveShift = 1;
            return;
        }

        const note = keyMappings[key];
        const midiSelect = document.getElementById('midi-select').value;

        if (note && !pressedKeys[key] && midiSelect === 'keyboard') {
            pressedKeys[key] = true;

            let fullNote = note;

            // Apply octave shift
            if (note.length === 3) { // e.g., C#4
                const noteName = note.slice(0, -1);
                let octave = parseInt(note.slice(-1)) + currentOctaveShift;
                // Ensure octave stays within 3 to 5
                octave = Math.min(Math.max(octave, 3), 5);
                fullNote = noteName + octave;
            } else if (note.length === 2) { // e.g., C4
                const noteName = note.slice(0, -1);
                let octave = parseInt(note.slice(-1)) + currentOctaveShift;
                // Ensure octave stays within 3 to 5
                octave = Math.min(Math.max(octave, 3), 5);
                fullNote = noteName + octave;
            }

            playNote(fullNote);
            handleUserInput(fullNote);
            highlightKey(fullNote);
        }
    });

    document.addEventListener('keyup', (event) => {
        const key = event.key.toLowerCase();

        // Handle octave shifting
        if (key === 'x' || key === 'c') {
            currentOctaveShift = 0;
            return;
        }

        if (pressedKeys[key]) {
            pressedKeys[key] = false;
        }
    });

    // ====================
    // Audio Playback Functions
    // ====================

    // Play a Single Note
    function playNote(note) {
        const frequency = noteFrequencies[note];
        if (!frequency) return;

        const oscillator = audioContext.createOscillator();
        oscillator.type = waveform;
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

        const envelope = audioContext.createGain();
        envelope.gain.setValueAtTime(0, audioContext.currentTime);
        envelope.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.001);
        envelope.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1);

        oscillator.connect(envelope);
        envelope.connect(audioContext.destination);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 1);
    }

    // Play Multiple Notes (Chords)
    function playNotes(notesArray, customWaveform = waveform) {
        notesArray.forEach(note => {
            const frequency = noteFrequencies[note];
            if (!frequency) return;

            const oscillator = audioContext.createOscillator();
            oscillator.type = customWaveform;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

            const envelope = audioContext.createGain();
            envelope.gain.setValueAtTime(0, audioContext.currentTime);
            envelope.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.001);
            envelope.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.5);

            oscillator.connect(envelope);
            envelope.connect(audioContext.destination);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + 1.5);
        });
    }

    </script>
</body>
</html>
