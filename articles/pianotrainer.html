<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Piano Trainer</title>
    <style>
    /* General Styles */
    body {
        font-family: Arial, sans-serif;
        background-color: #f0f0f0;
    }

    #game-container {
        text-align: center;
        margin: 20px auto;
        width: 90%;
        max-width: 1400px; /* Increased max-width to accommodate extended note range */
        background-color: #fff;
        padding: 20px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        border-radius: 8px;
    }

    /* Top Section: Piano and Instructions */
    #top-section {
        display: flex;
        justify-content: center;
        align-items: flex-start;
        gap: 20px;
    }

    /* Piano Styles */
    #piano {
        position: relative;
        width: 600px; /* Adjusted width after removing two keys */
        height: 200px;
    }

    .white-key, .black-key {
        position: absolute;
        border: 1px solid #000;
        border-radius: 0 0 5px 5px;
        cursor: pointer;
        user-select: none;
        display: flex;
        align-items: flex-end;
        justify-content: center;
        padding-bottom: 5px;
        font-size: 14px;
        color: #000;
    }

    .white-key {
        width: 50px;
        height: 200px;
        background: white;
        z-index: 1;
    }

    .black-key {
        width: 30px;
        height: 120px;
        background: black;
        color: white;
        z-index: 2;
    }

    /* Positioning White Keys */
    .white-key:nth-child(1) { left: 0px; }
    .white-key:nth-child(3) { left: 50px; }
    .white-key:nth-child(5) { left: 100px; }
    .white-key:nth-child(6) { left: 150px; }
    .white-key:nth-child(8) { left: 200px; }
    .white-key:nth-child(10) { left: 250px; }
    .white-key:nth-child(12) { left: 300px; }

    /* Positioning Black Keys */
    .black-key:nth-child(2) { left: 35px; }
    .black-key:nth-child(4) { left: 85px; }
    .black-key:nth-child(7) { left: 185px; }
    .black-key:nth-child(9) { left: 235px; }
    .black-key:nth-child(11) { left: 285px; }

    /* Highlighting Keys */
    .white-key.active {
        background: #ffd700;
    }

    .black-key.active {
        background: #ff8c00;
    }

    /* Feedback Display */
    #feedback {
        width: 800px;
        height: 50px;
        margin: 20px auto;
        transition: background-color 0.5s;
        border: 1px solid #ccc;
        border-radius: 5px;
    }

    /* Mode Buttons */
    #mode-buttons button {
        margin: 5px;
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
    }

    /* Waveform Selection */
    #waveform-selection {
        margin: 20px auto;
    }

    #waveform-selection label {
        margin-right: 10px;
        font-size: 16px;
    }

    #waveform-selection select {
        padding: 5px;
        font-size: 16px;
    }

    /* Metronome Controls */
    #metronome-controls {
        margin: 20px auto;
    }

    #metronome-controls h3 {
        margin-bottom: 10px;
    }

    #metronome-controls button {
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
    }

    #metronome-controls input {
        width: 60px;
        padding: 5px;
        font-size: 16px;
        margin-left: 10px;
    }

    /* Chord Settings */
    #chord-settings {
        margin: 20px auto;
    }

    #chord-settings h3 {
        margin-bottom: 10px;
    }

    #chord-settings select {
        padding: 5px;
        font-size: 16px;
        margin-right: 10px;
    }

    /* Staff Canvas */
    #staff {
        margin-top: 20px;
        border: 1px solid #ccc;
        border-radius: 5px;
    }

    /* MIDI Controls */
    #midi-controls {
        margin: 20px auto;
    }

    #midi-controls label {
        margin-right: 10px;
        font-size: 16px;
    }

    #midi-controls select {
        padding: 5px;
        font-size: 16px;
    }

    /* Instructions Box */
    #instructions {
        width: 400px; /* Adjusted width to fit beside piano */
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
        background-color: #fafafa;
        text-align: left;
    }

    #instructions p {
        margin: 0;
        font-size: 16px;
    }

    /* Note Range Selection */
    #note-range-selection {
        margin: 20px auto;
    }

    #note-range-selection label {
        margin-right: 10px;
        font-size: 16px;
    }

    #note-range-selection select {
        padding: 5px;
        font-size: 16px;
        margin-right: 20px;
    }

    /* Scale Settings */
    #scale-settings {
        margin: 20px auto;
    }

    #scale-settings h3 {
        margin-bottom: 10px;
    }

    #scale-settings label {
        margin-right: 10px;
        font-size: 16px;
    }

    #scale-settings select {
        padding: 5px;
        font-size: 16px;
        margin-right: 10px;
    }

    </style>
    <!-- Include VexFlow Library -->
    <script src="https://unpkg.com/vexflow/releases/vexflow-min.js"></script>
</head>
<body>
    <div id="game-container">
        <!-- Top Section: Piano and Instructions -->
        <div id="top-section">
            <!-- Piano Keyboard -->
            <div id="piano">
                <!-- White Keys -->
                <div class="white-key" data-note="C4">A</div>
                <div class="black-key" data-note="C#4">W</div>
                <div class="white-key" data-note="D4">S</div>
                <div class="black-key" data-note="D#4">E</div>
                <div class="white-key" data-note="E4">D</div>
                <div class="white-key" data-note="F4">F</div>
                <div class="black-key" data-note="F#4">T</div>
                <div class="white-key" data-note="G4">G</div>
                <div class="black-key" data-note="G#4">Y</div>
                <div class="white-key" data-note="A4">H</div>
                <div class="black-key" data-note="A#4">U</div>
                <div class="white-key" data-note="B4">J</div>
            </div>

            <!-- Instructions -->
            <div id="instructions">
                <p><strong>Instructions:</strong></p>
                <p>
                    - Use the keyboard or a MIDI controller to play notes.<br>
                    - Press <strong>'z'</strong> to shift all notes down by two octaves.<br>
                    - Press <strong>'x'</strong> to shift all notes down by one octave.<br>
                    - Press <strong>'c'</strong> to shift all notes up by one octave.<br>
                    - Press <strong>'v'</strong> to shift all notes up by two octaves.<br>
                    - Use the dropdowns to set the note range.<br>
                </p>
            </div>
        </div>

        <!-- Note Range Selection -->
        <div id="note-range-selection">
            <label for="low-note">Low Note:</label>
            <select id="low-note"></select>

            <label for="high-note">High Note:</label>
            <select id="high-note"></select>
        </div>

        <!-- Scale Settings -->
        <div id="scale-settings" style="display: none;">
            <h3>Scale Settings</h3>
            <label for="scale-type">Scale Type:</label>
            <select id="scale-type" onchange="setScaleType(this.value)">
                <option value="major">Major</option>
                <option value="natural_minor">Natural Minor</option>
                <option value="harmonic_minor">Harmonic Minor</option>
                <option value="melodic_minor">Melodic Minor</option>
                <!-- Add more scale types as needed -->
            </select>

            <label for="root-note">Root Note:</label>
            <select id="root-note" onchange="setRootNote(this.value)">
                <!-- Root notes will be populated dynamically -->
            </select>
        </div>

        <!-- Feedback Display -->
        <div id="feedback"></div>

        <!-- Mode Buttons -->
        <div id="mode-buttons">
            <button onclick="setMode('treble')">Treble Clef Mode</button>
            <button onclick="setMode('bass')">Bass Clef Mode</button>
            <button onclick="setMode('ear')">Ear Training Mode</button>
            <button onclick="setMode('scale')">Scales Mode</button> <!-- New Scales Mode Button -->
        </div>

        <!-- Waveform Selection -->
        <div id="waveform-selection">
            <label for="waveform">Select Waveform:</label>
            <select id="waveform" onchange="setWaveform(this.value)">
                <option value="sine">Sine</option>
                <option value="square">Square</option>
                <option value="triangle">Triangle</option>
                <option value="sawtooth">Sawtooth</option>
            </select>
        </div>

        <!-- Metronome Controls -->
        <div id="metronome-controls">
            <h3>Metronome</h3>
            <button onclick="toggleMetronome()">
                <span id="metronome-status">Start</span>
            </button>
            <label for="bpm">BPM:</label>
            <input type="number" id="bpm" value="120" min="40" max="240" onchange="setBPM(this.value)">
        </div>

        <!-- Chord Settings -->
        <div id="chord-settings">
            <h3>Chord Settings</h3>
            <label for="chord-size">Number of Notes:</label>
            <select id="chord-size" onchange="setChordSize(this.value)">
                <option value="1">Single Note</option>
                <option value="2">2 Notes</option>
                <option value="3">3 Notes</option>
                <option value="4">4 Notes</option>
            </select>
        </div>

        <!-- MIDI Controller Selection -->
        <div id="midi-controls">
            <label for="midi-select">MIDI Controller:</label>
            <select id="midi-select">
                <option value="keyboard">Keyboard</option>
                <!-- MIDI devices will be populated here -->
            </select>
        </div>

        <!-- Staff Canvas -->
        <canvas id="staff" width="800" height="200"></canvas>
    </div>

    <script>
    // ====================
    // Piano Trainer Script
    // ====================

    // Key Mappings
    const keyMappings = {
        'a': 'C4',
        'w': 'C#4',
        's': 'D4',
        'e': 'D#4',
        'd': 'E4',
        'f': 'F4',
        't': 'F#4',
        'g': 'G4',
        'y': 'G#4',
        'h': 'A4',
        'u': 'A#4',
        'j': 'B4'
    };

    // Reverse Mapping for Piano Keys (Optional if needed)
    const noteToKey = {
        'C4': 'a',
        'C#4': 'w',
        'D4': 's',
        'D#4': 'e',
        'E4': 'd',
        'F4': 'f',
        'F#4': 't',
        'G4': 'g',
        'G#4': 'y',
        'A4': 'h',
        'A#4': 'u',
        'B4': 'j'
    };

    // Initialize Audio Context (Declared Only Once)
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    // Variables
    let currentMode = 'treble';          // 'treble', 'bass', 'ear', 'scale'
    let targetNoteQueue = [];        // Queue of target notes or chords or scales
    let waveform = 'sine';           // Default waveform
    let metronomeInterval = null;
    let bpm = 75;                   // Default BPM
    let chordSize = 1;               // Default chord size
    let requiredNotes = new Set();   // Notes required for current chord input
    let currentOctaveShift = 0;      // 0: No shift, -1: Down 1, -2: Down 2, +1: Up 1, +2: Up 2

    // MIDI Variables
    let midiAccess = null;
    let midiInput = null;

    // Define all possible notes from C1 to B7 (only sharps, no flats)
    const allNotes = [
        // Octave 1
        'C1', 'C#1', 'D1', 'D#1', 'E1', 'F1', 'F#1', 'G1', 'G#1', 'A1', 'A#1', 'B1',
        // Octave 2
        'C2', 'C#2', 'D2', 'D#2', 'E2', 'F2', 'F#2', 'G2', 'G#2', 'A2', 'A#2', 'B2',
        // Octave 3
        'C3', 'C#3', 'D3', 'D#3', 'E3', 'F3', 'F#3', 'G3', 'G#3', 'A3', 'A#3', 'B3',
        // Octave 4
        'C4', 'C#4', 'D4', 'D#4', 'E4', 'F4', 'F#4', 'G4', 'G#4', 'A4', 'A#4', 'B4',
        // Octave 5
        'C5', 'C#5', 'D5', 'D#5', 'E5', 'F5', 'F#5', 'G5', 'G#5', 'A5', 'A#5', 'B5',
        // Octave 6
        'C6', 'C#6', 'D6', 'D#6', 'E6', 'F6', 'F#6', 'G6', 'G#6', 'A6', 'A#6', 'B6',
        // Octave 7
        'C7', 'C#7', 'D7', 'D#7', 'E7', 'F7', 'F#7', 'G7', 'G#7', 'A7', 'A#7', 'B7'
    ];
    const QUEUE_LENGTH = 8;           // Desired queue length

    // Note Frequencies
    const noteFrequencies = {
        // Octave 1
        'C1': 32.70, 'C#1': 34.65, 'D1': 36.71, 'D#1': 38.89, 'E1': 41.20,
        'F1': 43.65, 'F#1': 46.25, 'G1': 49.00, 'G#1': 51.91, 'A1': 55.00,
        'A#1': 58.27, 'B1': 61.74,
        // Octave 2
        'C2': 65.41, 'C#2': 69.30, 'D2': 73.42, 'D#2': 77.78, 'E2': 82.41,
        'F2': 87.31, 'F#2': 92.50, 'G2': 98.00, 'G#2': 103.83, 'A2': 110.00,
        'A#2': 116.54, 'B2': 123.47,
        // Octave 3
        'C3': 130.81, 'C#3': 138.59, 'D3': 146.83, 'D#3': 155.56, 'E3': 164.81,
        'F3': 174.61, 'F#3': 185.00, 'G3': 196.00, 'G#3': 207.65, 'A3': 220.00,
        'A#3': 233.08, 'B3': 246.94,
        // Octave 4
        'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'E4': 329.63,
        'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'G#4': 415.30, 'A4': 440.00,
        'A#4': 466.16, 'B4': 493.88,
        // Octave 5
        'C5': 523.25, 'C#5': 554.37, 'D5': 587.33, 'D#5': 622.25, 'E5': 659.25,
        'F5': 698.46, 'F#5': 739.99, 'G5': 783.99, 'G#5': 830.61, 'A5': 880.00,
        'A#5': 932.33, 'B5': 987.77,
        // Octave 6
        'C6': 1046.50, 'C#6': 1108.73, 'D6': 1174.66, 'D#6': 1244.51, 'E6': 1318.51,
        'F6': 1396.91, 'F#6': 1479.98, 'G6': 1567.98, 'G#6': 1661.22, 'A6': 1760.00,
        'A#6': 1864.66, 'B6': 1975.53,
        // Octave 7
        'C7': 2093.00, 'C#7': 2217.46, 'D7': 2349.32, 'D#7': 2489.02, 'E7': 2637.02,
        'F7': 2793.83, 'F#7': 2959.96, 'G7': 3135.96, 'G#7': 3322.44, 'A7': 3520.00,
        'A#7': 3729.31, 'B7': 3951.07
    };

    // Sharps to Flats Mapping
    const sharpToFlat = {
	'C#': 'Db',
	'D#': 'Eb',
	'F#': 'Gb',
	'G#': 'Ab',
	'A#': 'Bb'
    };
      
    function normalizeNote(note) {
        return note;
    }

    // Initialize Note Queue with 8 Notes or Chords or Scales
    function initializeNoteQueue() {
        targetNoteQueue = [];
        if (currentMode === 'scale') {
            generateScaleSequence();
        } else {
            for (let i = 0; i < QUEUE_LENGTH; i++) {
                if (chordSize === 1) {
                    const note = getRandomNote();
                    if (note) targetNoteQueue.push(createNoteObject(note));
                } else {
                    const chord = getRandomChord(chordSize);
                    if (chord.length === chordSize) { // Ensure full chord size
			const displayAsFlat = Math.random() < 0.5;
			const chordNoteObjects = chord.map(note => createNoteObject(note, displayAsFlat));
			targetNoteQueue.push(chordNoteObjects);
                    } else {
                        // If unable to generate full chord, fallback to single notes
                        const fallbackNote = getRandomNote();
                        if (fallbackNote) targetNoteQueue.push(fallbackNote);
                    }
                }
            }
            drawStaff();
            // Optionally, play the first note or chord to indicate the start
            if (currentMode === 'ear') {
                playEarTrainingNote();
            }
        }
    }

    // Handle User Input
    function handleUserInput(note) {
        if (targetNoteQueue.length === 0) return;

        const currentTarget = targetNoteQueue[0];
        if (currentMode === 'scale') {
            // Scale Mode: Check if the played note matches the current scale note
            const expectedNote = targetNoteQueue[0].note;
            const normalizedExpected = normalizeNote(expectedNote);
            const normalizedUser = normalizeNote(note);

            if (normalizedUser === normalizedExpected) {
                showFeedback('correct');
                // Move to the next note in the scale
                targetNoteQueue.shift();
                // Update the staff display
                drawStaff();
                // If in ear training mode, play the next note or chord
                if (currentMode === 'ear') {
                    setTimeout(() => {playEarTrainingNote();}, 500);
                }
                // If scale is completed, generate the next scale sequence
                if (targetNoteQueue.length === 0) {
                    generateScaleSequence();
                }
            } else {
                showFeedback('incorrect');
            }
        } else if (Array.isArray(currentTarget)) {
            // Chord Input
            requiredNotes.add(note);
            highlightKey(note);

            const normalizedTarget = currentTarget.map(n => n.note);
            const normalizedUser = Array.from(requiredNotes).map(normalizeNote);

            // Check if all required notes are pressed
            const isCorrect = normalizedTarget.every(n => normalizedUser.includes(n));
            if (isCorrect) {
                showFeedback('correct');
                // Remove the first chord
                targetNoteQueue.shift();
                // Add a new chord at the end
		const chord = getRandomChord(chordSize)
		const displayAsFlat = Math.random() < 0.5;
		const chordNoteObjects = chord.map(note => createNoteObject(note, displayAsFlat));
		console.log(chordNoteObjects);
		targetNoteQueue.push(chordNoteObjects);
                // Update the staff display
                drawStaff();
                // Reset required notes
                requiredNotes.clear();
                // If in ear training mode, play the next note or chord
                if (currentMode === 'ear') {
                    setTimeout(() => {playEarTrainingNote();}, 500);
                }
            } else {
                // Not all required notes pressed yet
                // Optionally, provide partial feedback or do nothing
            }
        } else {
            // Single Note Input
            const normalizedTargetNote = normalizeNote(currentTarget.note);
            const normalizedUserNote = normalizeNote(note);

            const delayDuration = 500;

            if (normalizedUserNote === normalizedTargetNote) {
                showFeedback('correct');
                // Remove the first note
                targetNoteQueue.shift();
                // Add a new note at the end
                targetNoteQueue.push(createNoteObject(getRandomNote()));
                // Update the staff display
                drawStaff();
                // If in ear training mode, play the next note
                if (currentMode === 'ear') {
                    setTimeout(() => {playEarTrainingNote();}, delayDuration)
                }
            } else {
                showFeedback('incorrect');
            }
        }
    }

    // Set Game Mode
    function setMode(mode) {
        currentMode = mode;
        if (mode === 'scale') {
            document.getElementById('scale-settings').style.display = 'block';
            document.getElementById('chord-settings').style.display = 'none';
        } else {
            document.getElementById('scale-settings').style.display = 'none';
            if (mode === 'ear') {
                document.getElementById('chord-settings').style.display = 'none';
            } else {
                document.getElementById('chord-settings').style.display = 'block';
            }
        }
        initializeNoteQueue();
    }

    // Get Random Single Note within the selected range with Octave Shift
    function getRandomNote() {
        const availableNotes = getNotesInRange(lowNote, highNote);
        if (availableNotes.length === 0) return null;

        const randomIndex = Math.floor(Math.random() * availableNotes.length);
        let note = availableNotes[randomIndex];

        return note;
    }

    // Get Random Chord of specified size within the selected range with notes at least 2 half-steps apart
    function getRandomChord(size) {
        const availableNotes = getNotesInRange(lowNote, highNote);
        if (availableNotes.length === 0) return [];

        // Sort availableNotes based on frequency to facilitate semitone difference
        const sortedNotes = availableNotes.slice().sort((a, b) => noteFrequencies[a] - noteFrequencies[b]);

        const chord = [];
        const usedIndices = new Set();

        for (let attempt = 0; attempt < 100; attempt++) { // Limit attempts to prevent infinite loops
            chord.length = 0;
            usedIndices.clear();

            while (chord.length < size) {
                const randIdx = Math.floor(Math.random() * sortedNotes.length);
                if (usedIndices.has(randIdx)) continue;

                const candidateNote = sortedNotes[randIdx];

                // Check semitone difference with existing chord notes
                let isValid = true;
                for (let existingNote of chord) {
                    const diff = getSemitoneDifference(existingNote, candidateNote);
                    if (diff < 2) {
                        isValid = false;
                        break;
                    }
                }

                if (isValid) {
                    chord.push(candidateNote);
                    usedIndices.add(randIdx);
                }

                if (usedIndices.size === sortedNotes.length) break;
            }

            if (chord.length === size) break;
        }

        return chord;
    }

    // Helper Function to Get Notes within the selected range
    function getNotesInRange(low, high) {
        const lowIndex = allNotes.indexOf(low);
        const highIndex = allNotes.indexOf(high);

        if (lowIndex === -1 || highIndex === -1 || lowIndex > highIndex) {
            return [];
        }

        return allNotes.slice(lowIndex, highIndex + 1);
    }

    // Helper Function to Apply Octave Shift
    function applyOctaveShift(note) {
        let shiftedNote = note;
        if (note.length === 3) { // e.g., C#4
            const noteName = note.slice(0, -1);
            let octave = parseInt(note.slice(-1)) + currentOctaveShift;
            // Ensure octave stays within 1 to 7
            octave = Math.min(Math.max(octave, 1), 7);
            shiftedNote = noteName + octave;
        } else if (note.length === 2) { // e.g., C4
            const noteName = note.slice(0, -1);
            let octave = parseInt(note.slice(-1)) + currentOctaveShift;
            // Ensure octave stays within 1 to 7
            octave = Math.min(Math.max(octave, 1), 7);
            shiftedNote = noteName + octave;
        }
        return shiftedNote;
    }

    // Helper Function to Calculate Semitone Difference
    function getSemitoneDifference(note1, note2) {
        const noteOrder = [
            'C1', 'C#1', 'D1', 'D#1', 'E1', 'F1', 'F#1', 'G1', 'G#1', 'A1', 'A#1', 'B1',
            'C2', 'C#2', 'D2', 'D#2', 'E2', 'F2', 'F#2', 'G2', 'G#2', 'A2', 'A#2', 'B2',
            'C3', 'C#3', 'D3', 'D#3', 'E3', 'F3', 'F#3', 'G3', 'G#3', 'A3', 'A#3', 'B3',
            'C4', 'C#4', 'D4', 'D#4', 'E4', 'F4', 'F#4', 'G4', 'G#4', 'A4', 'A#4', 'B4',
            'C5', 'C#5', 'D5', 'D#5', 'E5', 'F5', 'F#5', 'G5', 'G#5', 'A5', 'A#5', 'B5',
            'C6', 'C#6', 'D6', 'D#6', 'E6', 'F6', 'F#6', 'G6', 'G#6', 'A6', 'A#6', 'B6',
            'C7', 'C#7', 'D7', 'D#7', 'E7', 'F7', 'F#7', 'G7', 'G#7', 'A7', 'A#7', 'B7'
        ];
        const index1 = noteOrder.indexOf(note1);
        const index2 = noteOrder.indexOf(note2);
        return Math.abs(index1 - index2);
    }
      
    function createNoteObject(note, displayAsFlat = null) {
	if (displayAsFlat === null) {
	    // Decide whether to display as flat or sharp when the note is added
	    displayAsFlat = Math.random() < 0.5;
	}
	return { note: note, displayAsFlat: displayAsFlat };
    }      

    // Convert Note to VexFlow Key Format
    function noteToVexflowKey(noteObject) {
        // Use regex to parse the note into name, accidental, and octave
	const note = noteObject.note;
	const displayAsFlat = noteObject.displayAsFlat;
        const regex = /^([A-Ga-g])([#]?)(\d)$/;
        const match = note.match(regex);
        if (match) {
            const noteName = match[1].toLowerCase();
            const accidental = match[2];
            const octave = match[3];
	    let vexflowKey = noteName + '/' + octave;
	    let accidentalSymbol = null

	    if (displayAsFlat && accidental === '#') {
                const flatName = sharpToFlat[noteName.toUpperCase() + '#'];
                const flatNoteName = flatName[0].toLowerCase();
                const flatOctave = octave; // Assume same octave
                vexflowKey = flatNoteName + '/' + flatOctave;
                accidentalSymbol = 'b';
            } else {
                // Display as sharp
                vexflowKey = noteName + accidental + '/' + octave;
                accidentalSymbol = accidental;
            }
	    
            return {
                key: vexflowKey,
                accidental: accidentalSymbol
            };
        } else {
            console.error('Invalid note format:', note);
            return { key: 'c/4', accidental: null };
        }
    }

    // Draw Staff with Note Queue
    function drawStaff() {
        const canvas = document.getElementById('staff');
        const renderer = new Vex.Flow.Renderer(canvas, Vex.Flow.Renderer.Backends.CANVAS);
        const context = renderer.getContext();
        context.clearRect(0, 0, canvas.width, canvas.height);

        // Create a single stave
        const stave = new Vex.Flow.Stave(10, 40, 700);
        stave.addClef(currentMode === 'bass' ? 'bass' : 'treble');
        stave.setContext(context).draw();

        // Prepare StaveNotes
        const vfNotes = targetNoteQueue.map(item => {
	    if (Array.isArray(item)) {
	    // Chord - Prepare notes with their VexFlow data
    
		const chordNotes = item.map(note => {
                    const noteData = noteToVexflowKey(note);
                    return {
			key: noteData.key,
			accidental: noteData.accidental,
			frequency: noteFrequencies[note]
                    };
		});
		
            // Sort the chord notes based on frequency
            chordNotes.sort((a, b) => a.frequency - b.frequency);
            // Create the StaveNote with sorted keys
            const staveNote = new Vex.Flow.StaveNote({ 
                clef: currentMode === 'bass' ? 'bass' : 'treble', 
                keys: chordNotes.map(n => n.key), 
                duration: "q"
            });
            // Add accidentals to the chord
            chordNotes.forEach((note, index) => {
                if (note.accidental) {
                    staveNote.addAccidental(index, new Vex.Flow.Accidental(note.accidental));
                }
            });
            return staveNote;

            } else {
                // Single Note
                const noteData = noteToVexflowKey(item);
                const staveNote = new Vex.Flow.StaveNote({ 
                    clef: currentMode === 'bass' ? 'bass' : 'treble', 
                    keys: [noteData.key], 
                    duration: "q" 
                });
                if (noteData.accidental) {
                    staveNote.addAccidental(0, new Vex.Flow.Accidental(noteData.accidental));
                }
                return staveNote;
            }
        });

        if (vfNotes.length === 0) {
            // No notes to display
            return;
        }

        // Create a single voice with dynamic beats
        const voice = new Vex.Flow.Voice({
            num_beats: targetNoteQueue.length, // Dynamic number of beats
            beat_value: 4,                     // Quarter note
            resolution: Vex.Flow.RESOLUTION
        });

        voice.addTickables(vfNotes);

        // Create a formatter and format the voice
        const formatter = new Vex.Flow.Formatter()
            .joinVoices([voice])
            .format([voice], 680); // Adjust as needed

        // Draw the voice
        voice.draw(context, stave);
    }

    // Play Ear Training Note or Chord
    function playEarTrainingNote() {
        if (targetNoteQueue.length === 0) return;
        const currentTarget = targetNoteQueue[0].note;
        if (currentMode === 'scale') {
            playNote(currentTarget);
        } else if (Array.isArray(currentTarget)) {
            playNotes(currentTarget);
        } else {
            playNote(currentTarget);
        }
    }

    // Show Feedback
    function showFeedback(status) {
        const feedback = document.getElementById('feedback');
        if (status === 'correct') {
            feedback.style.backgroundColor = 'green';
        } else if (status === 'incorrect') {
            feedback.style.backgroundColor = 'red';
        }
        setTimeout(() => {
            feedback.style.backgroundColor = 'transparent';
        }, 500);
    }

    // Function to highlight a piano key
    function highlightKey(note) {
	// Select the key element based on the data-note attribute
	const keyElement = document.querySelector(`[data-note="${note}"]`);

	if (keyElement) {
	    // Add the 'active' class to highlight the key
	    keyElement.classList.add('active');

	    // Remove the 'active' class after 200 milliseconds to remove the highlight
	    setTimeout(() => {
		keyElement.classList.remove('active');
	    }, 200);
	}
    }


    // Set Waveform
    function setWaveform(wave) {
        waveform = wave;
    }

    // ====================
    // Scale Mode Functionality
    // ====================

    // Scale Definitions (Intervals in semitones)
    const scaleDefinitions = {
        'major': [2, 2, 1, 2, 2, 2, 1],
        'natural_minor': [2, 1, 2, 2, 1, 2, 2],
        'harmonic_minor': [2, 1, 2, 2, 1, 3, 1],
        'melodic_minor': [2, 1, 2, 2, 2, 2, 1],
        // Add more scale types as needed
    };

    let selectedScaleType = 'major';
    let selectedRootNote = 'C4';
    let scaleSequence = [];
    let scaleAscending = true;

    // Initialize Scale Settings Dropdowns
    function initializeScaleSettings() {
        const scaleTypeSelect = document.getElementById('scale-type');
        const rootNoteSelect = document.getElementById('root-note');

        // Populate root notes (C1 to B7)
        allNotes.forEach(note => {
            const option = document.createElement('option');
            option.value = note;
            option.text = note;
            rootNoteSelect.appendChild(option);
        });

        // Set default root note
        selectedRootNote = 'C4';
        rootNoteSelect.value = selectedRootNote;
    }

    // Set Scale Type
    function setScaleType(type) {
        if (scaleDefinitions[type]) {
            selectedScaleType = type;
            generateScaleSequence();
        }
    }

    // Set Root Note
    function setRootNote(note) {
        selectedRootNote = note;
        generateScaleSequence();
    }

    // Generate Scale Sequence (Ascending and Descending)
    function generateScaleSequence() {
        scaleSequence = [];
        const root = normalizeNote(selectedRootNote);
        const intervals = scaleDefinitions[selectedScaleType];
        if (!intervals) return;

	const displayAsFlat = Math.random() < 0.5;

        // Generate ascending scale
        let currentNote = root;
        if (isNoteWithinRange(currentNote)) {
            scaleSequence.push(createNoteObject(currentNote, displayAsFlat));
        }
        intervals.forEach(interval => {
            currentNote = getNoteBySemitoneInterval(currentNote, interval);
            if (currentNote) {
                scaleSequence.push(createNoteObject(currentNote, displayAsFlat));
            } else {
                // Stop if the next note is out of range
                return;
            }
        });

        // Generate descending scale
        const descendingScale = [];
        currentNote = scaleSequence[scaleSequence.length -1].note;
        const descendingIntervals = scaleDefinitions[selectedScaleType].slice().reverse();
        descendingIntervals.forEach(interval => {
            currentNote = getNoteBySemitoneInterval(currentNote, -interval);
            if (currentNote) {
                descendingScale.push(createNoteObject(currentNote, displayAsFlat));
            } else {
                // Stop if the next note is out of range
                return;
            }
        });

        scaleSequence = scaleSequence.concat(descendingScale);

        // Initialize the targetNoteQueue with the scale sequence
        targetNoteQueue = [...scaleSequence];
        drawStaff();
        // Optionally, play the first note
        if (currentMode === 'ear') {
            playEarTrainingNote();
        }
    }

    // Helper Function to Check if Note is Within Selected Range
    function isNoteWithinRange(note) {
        const lowIndex = allNotes.indexOf(lowNote);
        const highIndex = allNotes.indexOf(highNote);
        const noteIndex = allNotes.indexOf(note);
        return noteIndex >= lowIndex && noteIndex <= highIndex;
    }

    // Get Note by Semitone Interval
    function getNoteBySemitoneInterval(note, interval) {
        const noteIndex = allNotes.indexOf(note);
        if (noteIndex === -1) return null;
        const targetIndex = noteIndex + interval;
        if (targetIndex < 0 || targetIndex >= allNotes.length) return null;
        return allNotes[targetIndex];
    }

    // ====================
    // MIDI Support Functionality
    // ====================

    // Initialize MIDI
    function initMIDI() {
        if (navigator.requestMIDIAccess) {
            navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);
        } else {
            alert("Web MIDI API is not supported in this browser.");
        }
    }

    // Handle MIDI Access Success
    function onMIDISuccess(midi) {
        midiAccess = midi;
        listInputs(midiAccess);
        midiAccess.onstatechange = () => {
            listInputs(midiAccess);
        };
    }

    // Handle MIDI Access Failure
    function onMIDIFailure() {
        alert("Could not access your MIDI devices.");
    }

    // List MIDI Inputs and Populate Dropdown
    function listInputs(midiAccess) {
        const midiSelect = document.getElementById('midi-select');
        const selectedValue = midiSelect.value;
        // Remove all options except 'Keyboard'
        while (midiSelect.options.length > 1) {
            midiSelect.remove(1);
        }

        const inputs = midiAccess.inputs.values();
        for (let input of inputs) {
            const option = document.createElement('option');
            option.value = input.id;
            option.text = input.name;
            midiSelect.appendChild(option);
        }

        // If previously selected MIDI controller is disconnected, reset to Keyboard
        if (selectedValue !== 'keyboard') {
            const existingOption = Array.from(midiSelect.options).find(option => option.value === selectedValue);
            if (!existingOption) {
                midiSelect.value = 'keyboard';
                disableMIDI();
            }
        }
    }

    // Handle MIDI Selection Change
    document.getElementById('midi-select').addEventListener('change', function() {
        if (this.value === 'keyboard') {
            disableMIDI();
            enableKeyboard();
        } else {
            const selectedInput = midiAccess.inputs.get(this.value);
            if (selectedInput) {
                enableMIDI(selectedInput);
                disableKeyboard();
            }
        }
    });

    // Enable MIDI Input
    function enableMIDI(input) {
        midiInput = input;
        midiInput.onmidimessage = handleMIDIMessage;
    }

    // Disable MIDI Input
    function disableMIDI() {
        if (midiInput) {
            midiInput.onmidimessage = null;
            midiInput = null;
        }
    }

    // Enable Keyboard Input
    function enableKeyboard() {
        // No additional actions needed since keyboard listeners are always active
    }

    // Disable Keyboard Input
    function disableKeyboard() {
        // Optionally, remove keyboard listeners if you want to disable them
        // For now, we'll keep them active as per user request
    }

    // Handle MIDI Messages
    function handleMIDIMessage(message) {
        const [status, noteNumber, velocity] = message.data;
        const command = status & 0xF0;
        const channel = status & 0x0F;

        if (command === 0x90 && velocity > 0) { // Note on
            const noteName = midiNoteNumberToNoteName(noteNumber);
            if (noteName) {
                playNote(noteName);
                handleUserInput(noteName);
                highlightKey(noteName);
            }
        }
        // Note off (0x80) can be handled if needed
    }

    // Convert MIDI Note Number to Note Name
    function midiNoteNumberToNoteName(noteNumber) {
        const octave = Math.floor(noteNumber / 12) - 1;
        const noteIndex = noteNumber % 12;
        const sharpNoteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

        const noteName = sharpNoteNames[noteIndex];
        let fullNote = noteName + octave;

        // Apply octave shift
        let shiftedOctave = octave + currentOctaveShift;

        // Ensure octave stays within 1 to 7
        shiftedOctave = Math.min(Math.max(shiftedOctave, 1), 7);
        fullNote = noteName + shiftedOctave;

        return fullNote;
    }

    // Initialize Note Range Dropdowns
    function initializeNoteRangeDropdowns() {
        const lowNoteSelect = document.getElementById('low-note');
        const highNoteSelect = document.getElementById('high-note');

        // Populate the dropdowns with allNotes (only sharps, no flats)
        allNotes.forEach(note => {
            const option1 = document.createElement('option');
            option1.value = note;
            option1.text = note;
            lowNoteSelect.appendChild(option1);

            const option2 = document.createElement('option');
            option2.value = note;
            option2.text = note;
            highNoteSelect.appendChild(option2);
        });

        // Set default selections
        lowNote = 'F3';
        highNote = 'C6';

        lowNoteSelect.value = lowNote;
        highNoteSelect.value = highNote;

        // Add event listeners
        lowNoteSelect.addEventListener('change', () => {
            const selectedLow = lowNoteSelect.value;
            const selectedHigh = highNoteSelect.value;
            if (allNotes.indexOf(selectedLow) > allNotes.indexOf(selectedHigh)) {
                alert("Low Note cannot be higher than High Note.");
                lowNoteSelect.value = lowNote;
            } else {
                lowNote = selectedLow;
                if (currentMode !== 'scale') {
                    initializeNoteQueue();
                } else {
                    generateScaleSequence();
                }
            }
        });

        highNoteSelect.addEventListener('change', () => {
            const selectedLow = lowNoteSelect.value;
            const selectedHigh = highNoteSelect.value;
            if (allNotes.indexOf(selectedLow) > allNotes.indexOf(selectedHigh)) {
                alert("High Note cannot be lower than Low Note.");
                highNoteSelect.value = highNote;
            } else {
                highNote = selectedHigh;
                if (currentMode !== 'scale') {
                    initializeNoteQueue();
                } else {
                    generateScaleSequence();
                }
            }
        });
    }

    // Set Waveform
    function setWaveform(wave) {
        waveform = wave;
    }

    // ====================
    // Initialize Note Range and MIDI on Page Load
    // ====================

    window.addEventListener('load', () => {
        initializeNoteRangeDropdowns();
        initializeScaleSettings();
        initMIDI();
        initializeNoteQueue();
    });

    // ====================
    // Keyboard Event Handling with Debouncing and Octave Shift
    // ====================

    const pressedKeys = {};

    document.addEventListener('keydown', (event) => {
        const key = event.key.toLowerCase();

        // Handle octave shifting
        if (key === 'z') {
            currentOctaveShift = -2;
            return;
        }
        if (key === 'x') {
            currentOctaveShift = -1;
            return;
        }
        if (key === 'c') {
            currentOctaveShift = +1;
            return;
        }
        if (key === 'v') {
            currentOctaveShift = +2;
            return;
        }

        const note = keyMappings[key];
        const midiSelect = document.getElementById('midi-select').value;

        if (note && !pressedKeys[key] && midiSelect === 'keyboard') {
            pressedKeys[key] = true;

            let fullNote = note;

            // Apply octave shift
            if (note.length === 3) { // e.g., C#4
                const noteName = note.slice(0, -1);
                let octave = parseInt(note.slice(-1)) + currentOctaveShift;
                // Ensure octave stays within 1 to 7
                octave = Math.min(Math.max(octave, 1), 7);
                fullNote = noteName + octave;
            } else if (note.length === 2) { // e.g., C4
                const noteName = note.slice(0, -1);
                let octave = parseInt(note.slice(-1)) + currentOctaveShift;
                // Ensure octave stays within 1 to 7
                octave = Math.min(Math.max(octave, 1), 7);
                fullNote = noteName + octave;
            }

            playNote(fullNote);
            handleUserInput(fullNote);
            highlightKey(fullNote);
        }
    });

    document.addEventListener('keyup', (event) => {
        const key = event.key.toLowerCase();

        // Handle octave shifting
        if (key === 'z' || key === 'x' || key === 'c' || key === 'v') {
            currentOctaveShift = 0;
            return;
        }

        if (pressedKeys[key]) {
            pressedKeys[key] = false;
        }
    });

    // ====================
    // Audio Playback Functions
    // ====================

    // Play a Single Note
    function playNote(note) {
        const frequency = noteFrequencies[note];
        if (!frequency) return;

        const oscillator = audioContext.createOscillator();
        oscillator.type = waveform;
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

        const envelope = audioContext.createGain();
        envelope.gain.setValueAtTime(0, audioContext.currentTime);
        envelope.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.001);
        envelope.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1);

        oscillator.connect(envelope);
        envelope.connect(audioContext.destination);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 1);
    }

    // Play Multiple Notes (Chords)
    function playNotes(notesArray, customWaveform = waveform) {
        notesArray.forEach(note => {
            const frequency = noteFrequencies[note];
            if (!frequency) return;

            const oscillator = audioContext.createOscillator();
            oscillator.type = customWaveform;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

            const envelope = audioContext.createGain();
            envelope.gain.setValueAtTime(0, audioContext.currentTime);
            envelope.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.001);
            envelope.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.5);

            oscillator.connect(envelope);
            envelope.connect(audioContext.destination);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + 1.5);
        });
    }

    // ====================
    // Metronome Functionality
    // ====================

    // Toggle Metronome On/Off
    function toggleMetronome() {
        if (metronomeInterval) {
            clearInterval(metronomeInterval);
            metronomeInterval = null;
            document.getElementById('metronome-status').innerText = 'Start';
        } else {
            startMetronome();
            document.getElementById('metronome-status').innerText = 'Stop';
        }
    }

    // Start Metronome
    function startMetronome() {
        const interval = (60 / bpm) * 1000; // BPM to milliseconds
        metronomeInterval = setInterval(() => {
            playMetronomeTick();
        }, interval);
    }

    // Play Metronome Tick
    function playMetronomeTick() {
        const oscillator = audioContext.createOscillator();
        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(1000, audioContext.currentTime); // High pitch tick

        const envelope = audioContext.createGain();
        envelope.gain.setValueAtTime(0, audioContext.currentTime);
        envelope.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.001);
        envelope.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

        oscillator.connect(envelope);
        envelope.connect(audioContext.destination);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.2);
    }

    // Set BPM
    function setBPM(value) {
        bpm = parseInt(value);
        if (metronomeInterval) {
            clearInterval(metronomeInterval);
            startMetronome();
        }
    }

    // ====================
    // Chord Settings Functionality
    // ====================

    // Set Chord Size
    function setChordSize(value) {
        chordSize = parseInt(value);
        if (chordSize < 1) chordSize = 1;
        if (chordSize > 4) chordSize = 4; // Limit to 4 notes
        initializeNoteQueue();
    }
      
    </script>
</body>
</html>
