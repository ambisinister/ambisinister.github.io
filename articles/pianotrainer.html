<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Piano Trainer</title>
    <style>
    /* General Styles */
    body {
        font-family: Arial, sans-serif;
        background-color: #f0f0f0;
    }

    #game-container {
        text-align: center;
        margin: 20px auto;
        width: 90%;
        max-width: 1000px;
        background-color: #fff;
        padding: 20px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        border-radius: 8px;
    }

    /* Piano Styles */
    #piano {
        position: relative;
        width: 600px; /* Adjusted width after removing two keys */
        height: 200px;
        margin: 20px auto;
    }

    .white-key, .black-key {
        position: absolute;
        border: 1px solid #000;
        border-radius: 0 0 5px 5px;
        cursor: pointer;
        user-select: none;
        display: flex;
        align-items: flex-end;
        justify-content: center;
        padding-bottom: 5px;
        font-size: 14px;
        color: #000;
    }

    .white-key {
        width: 50px;
        height: 200px;
        background: white;
        z-index: 1;
    }

    .black-key {
        width: 30px;
        height: 120px;
        background: black;
        color: white;
        z-index: 2;
    }

    /* Positioning White Keys */
    .white-key:nth-child(1) { left: 0px; }
    .white-key:nth-child(3) { left: 50px; }
    .white-key:nth-child(5) { left: 100px; }
    .white-key:nth-child(6) { left: 150px; }
    .white-key:nth-child(8) { left: 200px; }
    .white-key:nth-child(10) { left: 250px; }
    .white-key:nth-child(12) { left: 300px; }

    /* Positioning Black Keys */
    .black-key:nth-child(2) { left: 35px; }
    .black-key:nth-child(4) { left: 85px; }
    .black-key:nth-child(7) { left: 185px; }
    .black-key:nth-child(9) { left: 235px; }
    .black-key:nth-child(11) { left: 285px; }

    /* Highlighting Keys */
    .white-key.active {
        background: #ffd700;
    }

    .black-key.active {
        background: #ff8c00;
    }

    /* Feedback Display */
    #feedback {
        width: 800px;
        height: 50px;
        margin: 20px auto;
        transition: background-color 0.5s;
        border: 1px solid #ccc;
        border-radius: 5px;
    }

    /* Mode Buttons */
    #mode-buttons button {
        margin: 5px;
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
    }

    /* Waveform Selection */
    #waveform-selection {
        margin: 20px auto;
    }

    #waveform-selection label {
        margin-right: 10px;
        font-size: 16px;
    }

    #waveform-selection select {
        padding: 5px;
        font-size: 16px;
    }

    /* Metronome Controls */
    #metronome-controls {
        margin: 20px auto;
    }

    #metronome-controls h3 {
        margin-bottom: 10px;
    }

    #metronome-controls button {
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
    }

    #metronome-controls input {
        width: 60px;
        padding: 5px;
        font-size: 16px;
        margin-left: 10px;
    }

    /* Chord Settings */
    #chord-settings {
        margin: 20px auto;
    }

    #chord-settings h3 {
        margin-bottom: 10px;
    }

    #chord-settings select {
        padding: 5px;
        font-size: 16px;
        margin-right: 10px;
    }

    /* Staff Canvas */
    #staff {
        margin-top: 20px;
        border: 1px solid #ccc;
        border-radius: 5px;
    }
          
    </style>
    <!-- Include VexFlow Library -->
    <script src="https://unpkg.com/vexflow/releases/vexflow-min.js"></script>
</head>
<body>
    <div id="game-container">
        <!-- Piano Keyboard -->
        <div id="piano">
            <!-- White Keys -->
            <div class="white-key" data-note="C4">A</div>
            <div class="black-key" data-note="C#4">W</div>
            <div class="white-key" data-note="D4">S</div>
            <div class="black-key" data-note="D#4">E</div>
            <div class="white-key" data-note="E4">D</div>
            <div class="white-key" data-note="F4">F</div>
            <div class="black-key" data-note="F#4">T</div>
            <div class="white-key" data-note="G4">G</div>
            <div class="black-key" data-note="G#4">Y</div>
            <div class="white-key" data-note="A4">H</div>
            <div class="black-key" data-note="A#4">U</div>
            <div class="white-key" data-note="B4">J</div>
        </div>

        <!-- Feedback Display -->
        <div id="feedback"></div>

        <!-- Mode Buttons -->
        <div id="mode-buttons">
            <button onclick="setMode('treble')">Treble Clef Mode</button>
            <button onclick="setMode('bass')">Bass Clef Mode</button>
            <button onclick="setMode('ear')">Ear Training Mode</button>
        </div>

        <!-- Waveform Selection -->
        <div id="waveform-selection">
            <label for="waveform">Select Waveform:</label>
            <select id="waveform" onchange="setWaveform(this.value)">
                <option value="sine">Sine</option>
                <option value="square">Square</option>
                <option value="triangle">Triangle</option>
                <option value="sawtooth">Sawtooth</option>
            </select>
        </div>

        <!-- Metronome Controls -->
        <div id="metronome-controls">
            <h3>Metronome</h3>
            <button onclick="toggleMetronome()">
                <span id="metronome-status">Start</span>
            </button>
            <label for="bpm">BPM:</label>
            <input type="number" id="bpm" value="120" min="40" max="240" onchange="setBPM(this.value)">
        </div>

        <!-- Chord Settings -->
        <div id="chord-settings">
            <h3>Chord Settings</h3>
            <label for="chord-size">Number of Notes:</label>
            <select id="chord-size" onchange="setChordSize(this.value)">
                <option value="1">Single Note</option>
                <option value="2">2 Notes</option>
                <option value="3">3 Notes</option>
                <option value="4">4 Notes</option>
                <option value="5">5 Notes</option>
            </select>
        </div>

        <!-- Staff Canvas -->
        <canvas id="staff" width="800" height="200"></canvas>
    </div>

    <script>
    // ====================
    // Piano Trainer Script
    // ====================

    // Key Mappings
    const keyMappings = {
        'a': 'C4',
        'w': 'C#4',
        's': 'D4',
        'e': 'D#4',
        'd': 'E4',
        'f': 'F4',
        't': 'F#4',
        'g': 'G4',
        'y': 'G#4',
        'h': 'A4',
        'u': 'A#4',
        'j': 'B4'
    };

    // Reverse Mapping for Piano Keys
    const noteToKey = {
        'C4': 'a',
        'C#4': 'w',
        'D4': 's',
        'D#4': 'e',
        'E4': 'd',
        'F4': 'f',
        'F#4': 't',
        'G4': 'g',
        'G#4': 'y',
        'A4': 'h',
        'A#4': 'u',
        'B4': 'j'
    };

    // Initialize Audio Context
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    // Variables
    let currentMode = null;          // 'treble', 'bass', 'ear'
    let previousMode = null;         // To store mode before 'chord'
    let targetNoteQueue = [];        // Queue of target notes or chords
    let waveform = 'sine';           // Default waveform
    let metronomeInterval = null;
    let bpm = 120;                   // Default BPM
    let chordSize = 1;               // Default chord size
    let activeChords = [];           // Currently active chord notes
    let requiredNotes = new Set();   // Notes required for current chord input

    const notes = ['C4', 'C#4', 'D4', 'D#4', 'E4', 'F4', 'F#4', 'G4', 'G#4', 'A4', 'A#4', 'B4'];
    const QUEUE_LENGTH = 8;           // Desired queue length

    // Note Frequencies
    const noteFrequencies = {
        'C4': 261.63,
        'C#4': 277.18,
        'D4': 293.66,
        'D#4': 311.13,
        'E4': 329.63,
        'F4': 349.23,
        'F#4': 369.99,
        'G4': 392.00,
        'G#4': 415.30,
        'A4': 440.00,
        'A#4': 466.16,
        'B4': 493.88
    };

    // Normalize Note (Map Flats to Sharps)
    function normalizeNote(note) {
        const flatToSharpMap = {
            'Db4': 'C#4',
            'Eb4': 'D#4',
            'Gb4': 'F#4',
            'Ab4': 'G#4',
            'Bb4': 'A#4'
        };
        return flatToSharpMap[note] || note;
    }

    // Play a Single Note
    function playNote(note) {
        const frequency = noteFrequencies[note];
        if (!frequency) return;

        const oscillator = audioContext.createOscillator();
        oscillator.type = waveform;
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

        const envelope = audioContext.createGain();
        envelope.gain.setValueAtTime(0, audioContext.currentTime);
        envelope.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.001);
        envelope.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1);

        oscillator.connect(envelope);
        envelope.connect(audioContext.destination);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 1);
    }

    // Play Multiple Notes (Chords)
    function playNotes(notesArray, customWaveform = waveform) {
        notesArray.forEach(note => {
            const frequency = noteFrequencies[note];
            if (!frequency) return;

            const oscillator = audioContext.createOscillator();
            oscillator.type = customWaveform;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

            const envelope = audioContext.createGain();
            envelope.gain.setValueAtTime(0, audioContext.currentTime);
            envelope.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.001);
            envelope.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.5);

            oscillator.connect(envelope);
            envelope.connect(audioContext.destination);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + 1.5);
        });
    }

    // Initialize Note Queue with 8 Notes or Chords
    function initializeNoteQueue() {
        targetNoteQueue = [];
        for (let i = 0; i < QUEUE_LENGTH; i++) {
            if (chordSize === 1) {
                targetNoteQueue.push(getRandomNote());
            } else {
                const chord = getRandomChord(chordSize);
                if (chord.length === chordSize) { // Ensure full chord size
                    targetNoteQueue.push(chord);
                } else {
                    // If unable to generate full chord, fallback to single notes
                    targetNoteQueue.push(getRandomNote());
                }
            }
        }
        drawStaff();
        // Optionally, play the first note or chord to indicate the start
        if (currentMode === 'ear') {
            playEarTrainingNote();
        }
    }

    // Handle User Input
    function handleUserInput(note) {
        if (targetNoteQueue.length === 0) return;

        const currentTarget = targetNoteQueue[0];
        if (Array.isArray(currentTarget)) {
            // Chord Input
            requiredNotes.add(note);
            highlightKey(note);
            const normalizedTarget = currentTarget.map(normalizeNote);
            const normalizedUser = Array.from(requiredNotes).map(normalizeNote);

            // Check if all required notes are pressed
            const isCorrect = currentTarget.every(targetNote => normalizedUser.includes(normalizeNote(targetNote)));
            if (isCorrect) {
                showFeedback('correct');
                // Remove the first chord
                targetNoteQueue.shift();
                // Add a new chord at the end
                targetNoteQueue.push(getRandomChord(chordSize));
                // Update the staff display
                drawStaff();
                // Reset required notes
                requiredNotes.clear();
                // If in ear training mode, play the next note or chord
                if (currentMode === 'ear') {
                    setTimeout(() => {playEarTrainingNote();}, 500);
                }
            } else {
                // Not all required notes pressed yet
                // Optionally, provide partial feedback or do nothing
            }
        } else {
            // Single Note Input
            const normalizedTargetNote = normalizeNote(currentTarget);
            const normalizedUserNote = normalizeNote(note);

            const delayDuration = 500;

            if (normalizedUserNote === normalizedTargetNote) {
                showFeedback('correct');
                // Remove the first note
                targetNoteQueue.shift();
                // Add a new note at the end
                targetNoteQueue.push(getRandomNote());
                // Update the staff display
                drawStaff();
                // If in ear training mode, play the next note
                if (currentMode === 'ear') {
                    setTimeout(() => {playEarTrainingNote();}, delayDuration)
                }
            } else {
                showFeedback('incorrect');
            }
        }
    }

    // Set Game Mode
    function setMode(mode) {
        currentMode = mode;
        initializeNoteQueue();
    }

    // Get Random Single Note
    function getRandomNote() {
        const randomIndex = Math.floor(Math.random() * notes.length);
        let note = notes[randomIndex]; // Always a sharp or natural note
        return note;
    }

    // Get Random Chord of specified size with notes at least 2 half-steps apart
    function getRandomChord(size) {
        const chord = [];
        let availableNotes = [...notes]; // Clone the notes array to avoid duplicates

        while (chord.length < size && availableNotes.length > 0) {
            const randomIndex = Math.floor(Math.random() * availableNotes.length);
            const selectedNote = availableNotes[randomIndex];
            chord.push(selectedNote);

            // Remove the selected note and its adjacent half-step notes
            availableNotes = availableNotes.filter(note => {
                const semitoneDifference = getSemitoneDifference(selectedNote, note);
                return semitoneDifference > 1;
            });
        }

        return chord;
    }

    // Helper Function to Calculate Semitone Difference
    function getSemitoneDifference(note1, note2) {
        const noteOrder = ['C4', 'C#4', 'D4', 'D#4', 'E4', 'F4', 'F#4', 'G4', 'G#4', 'A4', 'A#4', 'B4'];
        const index1 = noteOrder.indexOf(note1);
        const index2 = noteOrder.indexOf(note2);
        return Math.abs(index1 - index2);
    }

    // Convert Note to VexFlow Key Format
    function noteToVexflowKey(note) {
        // Use regex to parse the note into name, accidental, and octave
        const regex = /^([A-Ga-g])([#b]?)(\d)$/;
        const match = note.match(regex);
        if (match) {
            const noteName = match[1].toLowerCase();
            const accidental = match[2];
            const octave = match[3];
            return {
                key: noteName + '/' + octave,
                accidental: accidental
            };
        } else {
            console.error('Invalid note format:', note);
            return { key: 'c/4', accidental: null };
        }
    }

    // Draw Staff with Note Queue
    function drawStaff() {
        const canvas = document.getElementById('staff');
        const renderer = new Vex.Flow.Renderer(canvas, Vex.Flow.Renderer.Backends.CANVAS);
        const context = renderer.getContext();
        context.clearRect(0, 0, canvas.width, canvas.height);

        // Create a single stave
        const stave = new Vex.Flow.Stave(10, 40, 700);
        stave.addClef(currentMode === 'bass' ? 'bass' : 'treble');
        stave.setContext(context).draw();

        // Prepare StaveNotes
        const vfNotes = targetNoteQueue.map(item => {
            if (Array.isArray(item)) {
		
		const sortedItem = item.slice().sort((a, b) => noteFrequencies[a] - noteFrequencies[b]);
		
                // Chord
                const keys = sortedItem.map(note => {
                    const noteData = noteToVexflowKey(note);
                    return noteData.key;
                });
		
                const staveNote = new Vex.Flow.StaveNote({ 
                    clef: currentMode === 'bass' ? 'bass' : 'treble', 
                    keys: keys, 
                    duration: "q" 
                });
		
                // Add accidentals if necessary
                sortedItem.forEach((note, index) => {
                    const noteData = noteToVexflowKey(note);
                    if (noteData.accidental) {
                        staveNote.addAccidental(index, new Vex.Flow.Accidental(noteData.accidental));
                    }
                });
                return staveNote;
		
            } else {
                // Single Note
                const noteData = noteToVexflowKey(item);
                const staveNote = new Vex.Flow.StaveNote({ 
                    clef: currentMode === 'bass' ? 'bass' : 'treble', 
                    keys: [noteData.key], 
                    duration: "q" 
                });
                if (noteData.accidental) {
                    staveNote.addAccidental(0, new Vex.Flow.Accidental(noteData.accidental));
                }
                return staveNote;
            }
        });

// Draw Staff with Note Queue
function drawStaff() {
    const canvas = document.getElementById('staff');
    const renderer = new Vex.Flow.Renderer(canvas, Vex.Flow.Renderer.Backends.CANVAS);
    const context = renderer.getContext();
    context.clearRect(0, 0, canvas.width, canvas.height);

    // Create a single stave
    const stave = new Vex.Flow.Stave(10, 40, 700);
    stave.addClef(currentMode === 'bass' ? 'bass' : 'treble');
    stave.setContext(context).draw();

    // Prepare StaveNotes
    const vfNotes = targetNoteQueue.map(item => {
        if (Array.isArray(item)) {
            // Chord - Sort the notes in ascending order based on frequency
            const sortedItem = item.slice().sort((a, b) => noteFrequencies[a] - noteFrequencies[b]);

            const keys = sortedItem.map(note => {
                const noteData = noteToVexflowKey(note);
                return noteData.key;
            });

            const staveNote = new Vex.Flow.StaveNote({ 
                clef: currentMode === 'bass' ? 'bass' : 'treble', 
                keys: keys, 
                duration: "q" 
            });

            // Add accidentals if necessary
            sortedItem.forEach((note, index) => {
                const noteData = noteToVexflowKey(note);
                if (noteData.accidental) {
                    staveNote.addAccidental(index, new Vex.Flow.Accidental(noteData.accidental));
                }
            });

            return staveNote;
        } else {
            // Single Note
            const noteData = noteToVexflowKey(item);
            const staveNote = new Vex.Flow.StaveNote({ 
                clef: currentMode === 'bass' ? 'bass' : 'treble', 
                keys: [noteData.key], 
                duration: "q" 
            });
            if (noteData.accidental) {
                staveNote.addAccidental(0, new Vex.Flow.Accidental(noteData.accidental));
            }
            return staveNote;
        }
    });

    // Create a single voice with all quarter notes
    const voice = new Vex.Flow.Voice({
        num_beats: QUEUE_LENGTH, // 8 beats
        beat_value: 4,           // Quarter note
        resolution: Vex.Flow.RESOLUTION
    });

    voice.addTickables(vfNotes);

    // Create a formatter and format the voice
    const formatter = new Vex.Flow.Formatter()
        .joinVoices([voice])
        .format([voice], 680); // Slightly less than stave width to accommodate measure lines

    // Draw the voice
    voice.draw(context, stave);

    // Draw measure lines after every 4 notes (every 4 beats)
    const measureInterval = 4; // Every 4 beats
    const staveStartX = stave.getX();
    const staveWidth = stave.getWidth();
    const noteSpacing = staveWidth / QUEUE_LENGTH;
    for (let i = 1; i < QUEUE_LENGTH / measureInterval; i++) {
        const x = staveStartX + (i * measureInterval * noteSpacing);
        context.beginPath();
        context.moveTo(x, stave.getYForLine(0) - 20); // Adjust vertical position as needed
        context.lineTo(x, stave.getYForLine(4) + 20); // Adjust vertical position as needed
        context.strokeStyle = '#000';
        context.lineWidth = 1;
        context.stroke();
    }
}
	

        // Create a single voice with all quarter notes
        const voice = new Vex.Flow.Voice({
            num_beats: QUEUE_LENGTH, // 8 beats
            beat_value: 4,           // Quarter note
            resolution: Vex.Flow.RESOLUTION
        });

        voice.addTickables(vfNotes);

        // Create a formatter and format the voice
        const formatter = new Vex.Flow.Formatter()
            .joinVoices([voice])
            .format([voice], 680); // Slightly less than stave width to accommodate measure lines

        // Draw the voice
        voice.draw(context, stave);

        // Draw measure lines after every 4 notes (every 4 beats)
        const measureInterval = 4; // Every 4 beats
        const staveStartX = stave.getX();
        const staveWidth = stave.getWidth();
        const noteSpacing = staveWidth / QUEUE_LENGTH;
        for (let i = 1; i < QUEUE_LENGTH / measureInterval; i++) {
            const x = staveStartX + (i * measureInterval * noteSpacing);
            context.beginPath();
            context.moveTo(x, stave.getYForLine(0) - 20); // Adjust vertical position as needed
            context.lineTo(x, stave.getYForLine(4) + 20); // Adjust vertical position as needed
            context.strokeStyle = '#000';
            context.lineWidth = 1;
            context.stroke();
        }
    }

    // Play Ear Training Note or Chord
    function playEarTrainingNote() {
        if (targetNoteQueue.length === 0) return;
        const currentTarget = targetNoteQueue[0];
        if (Array.isArray(currentTarget)) {
            playNotes(currentTarget);
        } else {
            playNote(currentTarget);
        }
    }

    // Show Feedback
    function showFeedback(status) {
        const feedback = document.getElementById('feedback');
        if (status === 'correct') {
            feedback.style.backgroundColor = 'green';
        } else if (status === 'incorrect') {
            feedback.style.backgroundColor = 'red';
        }
        setTimeout(() => {
            feedback.style.backgroundColor = 'transparent';
        }, 500);
    }

    // Set Waveform
    function setWaveform(wave) {
        waveform = wave;
    }

    // ====================
    // Piano Keyboard Visual
    // ====================

    // Function to highlight key
    function highlightKey(note) {
        const keyElement = document.querySelector(`[data-note="${note}"]`);
        if (keyElement) {
            keyElement.classList.add('active');
            setTimeout(() => {
                keyElement.classList.remove('active');
            }, 300);
        }
    }

    // Event Listeners for Piano Clicks
    document.querySelectorAll('.white-key, .black-key').forEach(key => {
        key.addEventListener('mousedown', () => {
            const note = key.getAttribute('data-note');
            playNote(note);
            handleUserInput(note);
            highlightKey(note);
        });
    });

    // ====================
    // Metronome Functionality
    // ====================

    // Toggle Metronome On/Off
    function toggleMetronome() {
        if (metronomeInterval) {
            clearInterval(metronomeInterval);
            metronomeInterval = null;
            document.getElementById('metronome-status').innerText = 'Start';
        } else {
            startMetronome();
            document.getElementById('metronome-status').innerText = 'Stop';
        }
    }

    // Start Metronome
    function startMetronome() {
        const interval = (60 / bpm) * 1000; // BPM to milliseconds
        metronomeInterval = setInterval(() => {
            playMetronomeTick();
        }, interval);
    }

    // Play Metronome Tick
    function playMetronomeTick() {
        const oscillator = audioContext.createOscillator();
        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(1000, audioContext.currentTime); // High pitch tick

        const envelope = audioContext.createGain();
        envelope.gain.setValueAtTime(0, audioContext.currentTime);
        envelope.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.001);
        envelope.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

        oscillator.connect(envelope);
        envelope.connect(audioContext.destination);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.2);
    }

    // Set BPM
    function setBPM(value) {
        bpm = parseInt(value);
        if (metronomeInterval) {
            clearInterval(metronomeInterval);
            startMetronome();
        }
    }

    // ====================
    // Chord Settings Functionality
    // ====================

    // Set Chord Size
    function setChordSize(value) {
        chordSize = parseInt(value);
        if (chordSize < 1) chordSize = 1;
        if (chordSize > 5) chordSize = 5; // Limit to 5 notes
        initializeNoteQueue();
    }

    // ====================
    // Keyboard Event Handling with Debouncing
    // ====================

    const pressedKeys = {};

    document.addEventListener('keydown', (event) => {
        const note = keyMappings[event.key];
        if (note && !pressedKeys[event.key]) {
            pressedKeys[event.key] = true;
            playNote(note);
            handleUserInput(note);
            highlightKey(note);
        }
    });

    document.addEventListener('keyup', (event) => {
        if (pressedKeys[event.key]) {
            pressedKeys[event.key] = false;
        }
    });

    // Initialize the note queue when the page loads
    window.onload = () => {
        initializeNoteQueue();
    };
    </script>
</body>
</html>
