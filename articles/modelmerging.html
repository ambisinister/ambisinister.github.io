<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-07-23 Wed 15:07 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Model Merging</title>
<meta name="author" content="Eryk Banatt" />
<meta name="generator" content="Org Mode" />
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-101739190-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-101739190-1');
</script>


<link  href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js"></script>

<script>
var shiftWindow = function() { scrollBy(0, -50) };
if (location.hash) shiftWindow();
window.addEventListener("hashchange", shiftWindow);
</script>

<script type="text/javascript">

$(function() {
    'use strict';

    $("#text-table-of-contents ul:first").addClass('nav')
    $('body').attr('data-spy', 'scroll')
    $('body').attr('data-target', '#text-table-of-contents')
    $('body').attr('data-offset', '100')
    $('table').addClass('table table-striped table-bordered table-hover table-condensed')

    // Dark mode functionality
    function toggleDarkMode() {
        document.body.classList.toggle('dark-mode');
        const isDarkMode = document.body.classList.contains('dark-mode');
        localStorage.setItem('darkMode', isDarkMode);
        updateToggleButton();
    }

    function updateToggleButton() {
        const toggle = document.querySelector('.dark-mode-toggle');
        if (toggle) {
            toggle.innerHTML = document.body.classList.contains('dark-mode') ? '‚òÄÔ∏è' : 'üåô';
        }
    }

    // Initialize dark mode from localStorage
    const savedDarkMode = localStorage.getItem('darkMode');
    if (savedDarkMode === 'true') {
        document.body.classList.add('dark-mode');
    }

    // Add toggle button
    const toggleButton = document.createElement('div');
    toggleButton.className = 'dark-mode-toggle';
    toggleButton.innerHTML = document.body.classList.contains('dark-mode') ? '‚òÄÔ∏è' : 'üåô';
    toggleButton.addEventListener('click', toggleDarkMode);
    document.body.appendChild(toggleButton);

    updateToggleButton();
});
</script>

<link rel="stylesheet" type="text/css" href="https://planetbanatt.net/css/default_20240614.css" />
<link rel="shortcut icon" type="image/jpg" href="https://planetbanatt.net/favicon.ico" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">

<!-- heading -->
<!-- add here -->

<!-- Fixed navbar -->
    <nav class="navbar navbar-default navbar-fixed-top">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>

        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav ml-auto" style="margin-left:3%">
            <li class="nav-item"><a href="http://planetbanatt.net/">Home</a></li>
            <li><a href="http://planetbanatt.net/about.html">About</a></li>
            <li><a href="http://planetbanatt.net/projects.html">Projects</a></li>
            <li><a href="http://planetbanatt.net/melee/index.html">Melee</a></li>
            <li><a href="http://planetbanatt.net/links.html">Links</a></li>
            <li><a href="http://planetbanatt.net/resume.pdf">Resume</li>
          </ul>
          </ul>
        </div><!--/.nav-collapse -->
    </nav>
</div>
<div id="content" class="content">
<h1 class="title">Model Merging</h1>
<div id="table-of-contents" role="doc-toc">
<h1>Table of Contents</h1>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org8ed27b3">Model Merging and You</a>
<ul>
<li><a href="#org9b6353b">Some Prerequisite Info + Acknowledgements</a></li>
<li><a href="#org9bba2ea">Convergent Learning: Do Different Neural Networks Learn the Same Representations?</a></li>
<li><a href="#org82f9a08">(SLERP) Sampling Generative Networks</a></li>
<li><a href="#org7742a88">Model Soups: averaging weights of multiple fine-tuned models improves accuracy without increasing inference time</a></li>
<li><a href="#org8a3180c">Fusing Finetuned Models for Better Pretraining</a></li>
<li><a href="#org35bb97b">Merging Models with Fisher-Weighted Averaging</a></li>
<li><a href="#org79b97ec">Git Re-Basin</a></li>
<li><a href="#org70f8b25">Editing Models with Task Arithmetic</a></li>
<li><a href="#orgfdaf940">TIES-MERGING</a></li>
<li><a href="#orga3478e5">(DARE) Language Models are Super Mario: Absorbing Abilities from Homologous Models as a Free Lunch</a></li>
<li><a href="#org2f3723e">Model Breadcrumbs: Scaling Multi-Task Model Merging with Sparse Masks</a></li>
<li><a href="#orgdbddd1a">Model Stock: All we need is just a few fine-tuned models</a></li>
<li><a href="#org3450da0">DELLA-Merging: Reducing Interference in Model Merging through Magnitude-Based Sampling</a></li>
<li><a href="#org3120d32">Evolutionary Optimization of Model Merging Recipes</a>
<ul>
<li><a href="#orge9c94b7">Merging Parameters</a></li>
<li><a href="#org0f067bb">Merging Data Flow</a></li>
<li><a href="#orgb7b6d62">Thoughts</a></li>
</ul>
</li>
<li><a href="#org0d438b8">Frankenmerging</a>
<ul>
<li><a href="#org6f9cd95">Understanding Robustness of Transformers for Image Classification</a></li>
<li><a href="#orgad6fbef">Transformer Layers as Painters</a></li>
<li><a href="#orgf613f37">SOLAR 10.7B: Scaling Large Language Models with Simple yet Effective Depth Up-Scaling</a></li>
</ul>
</li>
<li><a href="#org85127e9">Appendix: Other Papers</a>
<ul>
<li><a href="#org30c3264">Dataless Knowledge Fusion by Merging Weights of Language Models</a></li>
<li><a href="#orgc0a56fa">Reading List</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org8ed27b3" class="outline-1">
<h1 id="org8ed27b3">Model Merging and You</h1>
<div class="outline-text-1" id="text-org8ed27b3">
<p>
Model Merging is a weird and experimental technique which lets you take two models and combine them together to get a new model. This is primarily used in Large Language Models, where the likely convergent representations allow this technique to work somewhat better than you might expect, given the concept. Model merging techniques are interesting since they allow researchers to create new models which are somehow performant in new ways despite not doing any additional training. I think this is really weird, so I need to know about it.
</p>

<p>
There is some work applying these sorts of merges to vision models, too, like Stable Diffusion. People will often train several adapters (e.g. one for style, one for subject, etc) and then combine them all upon the base model to get something which is performant on all the sub-tasks that were trained. We are going to read a lot of papers and try to get some sense for why this works. 
</p>

<p>
There are many good <a href="https://huggingface.co/blog/mlabonne/merge-models">resources</a> out there for understanding how to apply mergekit to large language models. I am interested in building some intuition upon how and why these methods work, and specifically if there's any room for applying these techniques to other types of models, or other problems.
</p>

<p>
This document is a work in progress: I will be spending some cycles on model merging and will periodically update this page as I continue to read about it.
</p>
</div>

<div id="outline-container-org9b6353b" class="outline-2">
<h2 id="org9b6353b">Some Prerequisite Info + Acknowledgements</h2>
<div class="outline-text-2" id="text-org9b6353b">
<p>
For actually performing the merging, at least for LLMs, <a href="https://github.com/arcee-ai/mergekit?tab=readme-ov-file#merge-methods">mergekit</a> is a popular repo. It has a bunch of different methods, as well as it's own <a href="https://arxiv.org/pdf/2403.13257">paper</a> which I'll include for completeness.
</p>

<p>
A lot of these papers come from <a href="https://huggingface.co/collections/osanseviero/model-merging-65097893623330a3a51ead66">osanseviero's model merging collection</a>, where I followed rabbit holes in specific papers when they appeared. 
</p>

<p>
If you want a more comprehensive summary, here's a <a href="https://arxiv.org/pdf/2309.15698">survey paper</a> which covers non-frankenmerging topics in model merging.
</p>

<p>
Many thanks to the Sakana AI team, specifically Yujin Tang, Takuya Akiba, and Qi Sun for responding to my inquiries about model merging in a friendly and timely fashion.
</p>
</div>
</div>

<div id="outline-container-org9bba2ea" class="outline-2">
<h2 id="org9bba2ea">Convergent Learning: Do Different Neural Networks Learn the Same Representations?</h2>
<div class="outline-text-2" id="text-org9bba2ea">
<p>
Paper can be found <a href="https://arxiv.org/abs/1511.07543">here</a>. This is an old paper from 2016, but we're starting with it because it was an early paper which explored the idea that two independent networks trained on similar data could converge upon similar features, even if they happen to be permuted.
</p>

<p>
This paper trained a number of AlexNet models on ImageNet data, and then compared how similar the filters were to the closest matches in the corresponding other model. They make 5 main observations:
</p>

<ol class="org-ol">
<li>The core representation is the same, but rare features sometimes appear in one model and not the other.</li>
<li>One-to-one alignment of neurons holds even if you use different measures of similarity (i.e. it's not some weird artifact of the metric)</li>
<li>We can create a transformation which converts one model's representation into the other's (!!!)</li>
<li>We can see many-to-many mappings between clusters of neurons as well, on top of just at the neuron level</li>
<li>The activation statistics between matching neurons are mostly similar as well</li>
</ol>

<p>
To run these experiments, they do multiple training runs with the same architecture upon the same data. This makes it pretty likely that the features it would learn would be roughly the same, but in different spots due to random initialization. They then use bipartite semi-matching<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup> to pair each filter with its most likely counterpart in the network. A good number of these are almost perfect matches, but the worst matches suggest that each network has some set of "rare features" that it learned, departing from the other network<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>. 
</p>


<div id="org496b045" class="figure">
<p><img src="../images/from_clipboard/20240731_101104.png" alt="20240731_101104.png" />
</p>
</div>

<p>
To really show how the two are related, they learn a single "mapping" layer (a LASSO model, with an L1 penalty) which will predict one network's representation when provided the other. They can use the sparse prediction loss for this layer as a metric for how similar the representations are (i.e. if the loss is very low, the representations are likely to be more like a permutation, but if it's high there's probably lots of different features which don't match). 
</p>


<div id="orgd1848f2" class="figure">
<p><img src="../images/from_clipboard/20240731_102448.png" alt="20240731_102448.png" />
</p>
</div>

<p>
There's some good discussion here about <i>local</i> vs <i>distributed</i> representations, i.e. ones which can be directly matched one-to-one and ones which are still easy to predict by the mapping layer despite not mapping one-to-one. The result here is interesting because it suggests a pretty high degree of local mapping, suggesting that the neurons are learning important specific vectors individually rather than just being a collection of essentially random basis vectors which describe some specific subspace<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>. 
</p>

<p>
Okay: how does this help us with model merging? Here's some takeaways:
</p>

<ul class="org-ul">
<li>Similar features learned between networks trained on similar / the same tasks</li>
<li>Possible to create a mapping transforming one model's representation to the other's</li>
<li>From the future work section: "Model Combination: Can multiple models be combined by concatenating their features, deleting those with high overlap, and then fine-tuning?"</li>
</ul>

<p>
Also probably the biggest takeaway: these models are start from unique initializations, and as a result of the random initialization they don't share the same initial optimization trajectories, meaning all of these shared features are somewhere in the model but in a random arrangement. If we finetune some sort of source model and then "break off" from there, it's really likely that the features are all going to be in the same spots, with the differences then being about the subsequent differences from different data / hyperparameters / whatever. Indeed this was exactly what was later shown in <a href="https://arxiv.org/pdf/1912.05671">Linear Mode Connectivity and the Lottery Ticket Hypothesis</a>. This informs a lot of the methods which follow from here!
</p>
</div>
</div>

<div id="outline-container-org82f9a08" class="outline-2">
<h2 id="org82f9a08">(SLERP) Sampling Generative Networks</h2>
<div class="outline-text-2" id="text-org82f9a08">
<p>
Paper can be found <a href="https://arxiv.org/pdf/1609.04468">here</a>. This paper is also an older one, from 2016.
</p>

<p>
This paper is specifically about sampling from generative networks, but the core idea of the paper was later applied to model merging. Say you want to sample between two points from a generative model (e.g. interpolate between a human and a tiger). One naive thing you could do is simple linear interpolation, where you take the weights which generated the first image, the weights that generated the second image, and take a straight line between these two points and sample along the way at regular intervals. This will, in principle, get you a series of images which start and end with your images.
</p>

<p>
However, latent spaces are high dimensional, and traveling along linear paths like this are extremely unlikely given the gaussian / uniform priors these models typically have. What would be better if you could interpolate along the <a href="https://en.wikipedia.org/wiki/Geodesic">geodesic</a> in that high-dimensional space, which is more in line with what you want (a "straight line" between both points &#x2013; in a curved space this isn't a linear interpolation).
</p>

<p>
They propose using <i>SLERP</i>, which is a spherical linear interpolation along an n-dimensional hypersphere. This seems to do better.
</p>


<div id="org8c6966a" class="figure">
<p><img src="../images/from_clipboard/20240731_110449.png" alt="20240731_110449.png" />
</p>
</div>

<p>
Stable Diffusion finetunes are commonly SLERPed together like this &#x2013; often the more popular models aren't base model but rather models with a bunch of these community finetunes SLERPED on top of each other in the weight space<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup>. 
</p>
</div>
</div>

<div id="outline-container-org7742a88" class="outline-2">
<h2 id="org7742a88">Model Soups: averaging weights of multiple fine-tuned models improves accuracy without increasing inference time</h2>
<div class="outline-text-2" id="text-org7742a88">
<p>
Paper can be found <a href="https://arxiv.org/abs/2203.05482">here</a>. This paper is from 2022, and was one of the early modern "model merging" works<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup>.
</p>

<p>
The core idea here is that instead of selecting the best-performing model training run, or making an ensemble from all the trained models, we can just literally average together the weights and get the benefits of an ensemble with only one model's worth of inference and memory costs. This is a pretty interesting result: the averaged weights of multiple models yield a model which outperforms any individual model! They used this to break state-of-the-art on ImageNet. Core to this is that they're all the same architecture and trained on the same data (just with varying hyperparameters).
</p>

<p>
A lot of this relies on an <a href="https://arxiv.org/pdf/2008.11687">earlier result</a> which showed that "fine-tuned models optimized independently from the same pre-trained initialization lie in the same basin of the error landscape". There was also some earlier work averaging the weights of a single model along a single training run (maintaining a sort of moving average), but this work extended it to combining several models trained independently. They actually show this in figure 2 directly:
</p>


<div id="orga32a342" class="figure">
<p><img src="../images/from_clipboard/20240731_131554.png" alt="20240731_131554.png" />
</p>
</div>

<p>
Specifically they find that using held-out data and taking a greedy approach to averaging in new models (adding them if they increase performance on held-out data) is the best way to do this. They find that this seems slightly worse than ensembles on test, and slightly better than ensembles under distribution shift. They use CLIP ViT-L, ViT-G, ALIGN (uses efficientnet for vision encoder), BASIC, a big variety of models of different types.
</p>

<p>
The related work has some interesting caveats: <a href="https://arxiv.org/pdf/1912.05671">Linear Mode Connectivity and the Lottery Ticket Hypothesis</a> showed different data order makes simple weight averaging ineffective (i.e. equivalent to random), but that if the two models share some part of their optimization trajectory, that suddenly averaging them works well again. In <a href="https://arxiv.org/pdf/2008.11687">What is being transferred in transfer learning?</a> it was shown that interpolating between two finetunes will have at least the accuracy of the endpoints.
</p>
</div>
</div>

<div id="outline-container-org8a3180c" class="outline-2">
<h2 id="org8a3180c">Fusing Finetuned Models for Better Pretraining</h2>
<div class="outline-text-2" id="text-org8a3180c">
<p>
<a href="https://arxiv.org/pdf/2204.03044">Paper can be found here</a>. This is a 2022 model averaging paper which concludes that for adapting a model to a new task, it's often better to average together different finetunes compared to using pretrained models.
</p>


<div id="org7ca0e6f" class="figure">
<p><img src="../images/from_clipboard/20240819_170843.png" alt="20240819_170843.png" />
</p>
</div>

<p>
Conceptually this paper is a bit like the model soups paper, but instead of many random finetuning runs upon the same data, it first merges together several models which were finetuned from the same base model for different tasks. For example, consider a base model for which three finetunes have been produced: one for text classification, one for natural language inference, and one for twitter irony detection. If you wanted to train this model on a fourth task, your instinct might be to start from the base model and do another finetune, but this paper claims that first merging finetunes for other tasks may result in superior pretraining for the new task.
</p>

<p>
This paper has some significance for us here because it's one of the few papers in here which is explicitly about <i>further training</i> the resulting merged model, rather than simply edging out the best performance at test time. Conceptually their results are easy to grasp: you want to pick the checkpoint which is already closest to your target task, and if your task is conceptually "between" two existing pretrained models, it might be closer to the solution to use a merged pretraining start point compared to using one of the finetunes (or the base model).
</p>

<p>
There's also some notes in here about how weight decay empirically destroys the benefits of starting with one of the finetunes, but doesn't seem to do that for merged models. This isn't supported by anything other than experiment, but it's interesting to note.
</p>
</div>
</div>

<div id="outline-container-org35bb97b" class="outline-2">
<h2 id="org35bb97b">Merging Models with Fisher-Weighted Averaging</h2>
<div class="outline-text-2" id="text-org35bb97b">
<p>
The paper can be found <a href="https://arxiv.org/pdf/2111.09832">here</a>. 
</p>

<p>
This paper frames the model merging process as approximately maximizing the joint likelihood of the models' posterior distribution over parameters, and that if you use an isotropic gaussian distribution to approximate the posterior, maximizing this joint likelihood is equivalent to just averaging the weights. They call this <i>isotropic merging</i> as a result.
</p>

<p>
In contrast, they think a better way to approximate this posterior would yield a better result. So, use the Laplace approximation instead, by taking the diagonal of each model's <a href="https://en.wikipedia.org/wiki/Fisher_information">Fisher information matrix</a> as the precision matrix for that model's posterior. They call this <i>Fisher merging</i> to distinguish it from isotropic merging, and they show that it's often a bit better.
</p>


<div id="orgbea5e99" class="figure">
<p><img src="../images/from_clipboard/20240731_173548.png" alt="20240731_173548.png" />
</p>
</div>


<div id="org9e60ac1" class="figure">
<p><img src="../images/from_clipboard/20240731_173631.png" alt="20240731_173631.png" />
</p>
</div>

<p>
The difference here is pretty subtle, but it does seem a little bit better than normal averaging<sup><a id="fnr.6" class="footref" href="#fn.6" role="doc-backlink">6</a></sup>. 
</p>
</div>
</div>

<div id="outline-container-org79b97ec" class="outline-2">
<h2 id="org79b97ec">Git Re-Basin</h2>
<div class="outline-text-2" id="text-org79b97ec">
<p>
This paper can be found <a href="https://arxiv.org/abs/2209.04836">here</a>. 
</p>

<p>
This paper's thesis is very interesting. The core idea is that there's usually a single optimal basin in the loss landscape once you account for all the possible permutations (which are all essentially the same solution, just permuted to be in a different location). This means if we can figure out how to permute two models to have the same arrangement of hidden units, we should pretty much always be able to merge the two models.
</p>

<p>
Basically, this paper tries to solve the permutation problem we saw in the convergent learning paper.
</p>


<div id="orgd98fd66" class="figure">
<p><img src="../images/from_clipboard/20240731_211709.png" alt="20240731_211709.png" />
</p>
</div>

<p>
They provide three methods for matching units between two different models.
</p>

<ol class="org-ol">
<li>Match the activations by performing Ordinary Least Squares (OLS) regression to solve a linear assignment problem (LAP), which is an old and well-studied problem which has lots of efficient solutions.</li>
<li>Match the weights by solving a "sum of bilinear assignments problem" (SOBLAP) (unlike 1 this is NP hard, but can be solved via approximation and ignores the data distribution completely)</li>
<li>Learn a straight-through estimator which specifically learns a correct permutation</li>
</ol>


<div id="org4edba4d" class="figure">
<p><img src="../images/from_clipboard/20240731_215742.png" alt="20240731_215742.png" />
</p>
</div>

<p>
Straight-through estimator performs the best, but the other methods are almost as good and much cheaper &#x2013; especially algorithm 1, which runs in a few seconds and doesn't require access to data. Unlike the other papers in here this paper is pretty dense, quite theoretical rather than being hacky. They don't always get zero-barrier (i.e. in the same loss basin) but usually they get a big reduction which enables some sort of merge to be possible.
</p>

<p>
Thankfully they have <a href="https://github.com/samuela/git-re-basin">code</a>, actually code for the actual methods, see <a href="https://github.com/samuela/git-re-basin/blob/main/src/weight_matching.py">weight-matching.py</a> which actually does algorithm 1 in there. It's in Jax though.
</p>

<p>
This isn't used that much in the papers which follow, which mostly deal with merging finetunes together. It seems like it should be necessary for language models in particular (note that this is a general model merging paper), since those often don't even have the same architecture, but for some reason they seem unnecessary there. 
</p>
</div>
</div>

<div id="outline-container-org70f8b25" class="outline-2">
<h2 id="org70f8b25">Editing Models with Task Arithmetic</h2>
<div class="outline-text-2" id="text-org70f8b25">
<p>
Paper can be found <a href="https://arxiv.org/pdf/2212.04089">here</a>. 
</p>

<p>
<i>Task Arithmetic</i> builds task vectors by subtracting pre-trained weights from fine-tuned model weights. What you get as a result is a vector where if you apply it to the base model, you improve it at that task. If you build a bunch of task vectors, you can do interesting vector arithmetic with them: negating the vector will make you worse at that task, adding task vectors together will make your model better at both things, etc. You can even improve performance through task analogies, e.g. <i>A is to B as C is to D</i>, where adding A, B, and C to the model as task vectors will improve D even with no data or training directly on that task.
</p>

<p>
This is interesting because we can <i>remove</i> things by training models which <i>do</i> those things. For example, if we train a toxic model and then add the negated toxic task vector, we get a less toxic model. We can <i>learn via addition</i> or <i>forget via negation</i>. Task analogies work a similar way: for example, we can approximate a task vector for "Yelp Sentiment Classification" by starting from "Amazon Sentiment Classification", adding "Yelp Language Modeling" and subtracting "Amazon Language Modeling". 
</p>


<div id="orga23a213" class="figure">
<p><img src="../images/from_clipboard/20240731_145513.png" alt="20240731_145513.png" />
</p>
</div>

<p>
The above is essentially the entire content of the paper, it's very simple. The rest after this figure is formalization (\(\theta_{new} = \theta + \lambda\tau\) where \(\tau = \theta_{ft} - \theta_{pre}\), and this is equivalent to a full finetune when \(\lambda = 1\)) and experiments on a variety of image and natural language processing models/tasks.
</p>

<p>
The discussion section has a lot of really interesting points. One big finding they see is that vectors from different tasks are close to orthogonal, which is what you would expect if the different tasks are essentially random vectors (which are likely to be close to orthogonal in high dimension). This likely helps explain why adding them together seems to cause minimal interference with each task. Likewise, intermediate task vectors seem to converge very quickly to the appropriate direction, suggesting that you could even potentially do crazy things like halt training early and just modify the magnitude of the task vector instead. They also reference the <a href="https://arxiv.org/pdf/2209.04836">git re-basin</a> paper as potential work where the merging could occur between models which are not derivatives of the same base model.
</p>

<p>
Overall this seems like a promising merging direction, and in general seems like a cool step towards making models more generally interpretable in the first place. One could imagine a model with tons of these little task vectors applied to it, where you can visibly modify specific behaviors this way. 
</p>
</div>
</div>

<div id="outline-container-orgfdaf940" class="outline-2">
<h2 id="orgfdaf940">TIES-MERGING</h2>
<div class="outline-text-2" id="text-orgfdaf940">
<p>
The paper can be found <a href="https://papers.nips.cc/paper_files/paper/2023/file/1644c9af28ab7916874f6fd6228a9bcf-Paper-Conference.pdf">here</a>. 
</p>

<p>
Existing merging methods tend to ignore interference between parameters of different models, and this is what the authors claim is the source of performance drops during merges. The two major sources of said interference are 1: redundant parameter values, and 2: disagreement on the sign of a parameter's value.
</p>

<p>
TIES-MERGING stands for&#x2026; TrIm, Elect Sign and MERGE<sup><a id="fnr.7" class="footref" href="#fn.7" role="doc-backlink">7</a></sup>. This, appropriately, has three steps. First, clip parameters that only changed a little bit during training. Second, resolve the sign conflicts. Third, merge only the parameters that are in alignment with agreed-upon sign. This seems to help!
</p>


<div id="orge27a551" class="figure">
<p><img src="../images/from_clipboard/20240731_154456.png" alt="20240731_154456.png" />
</p>
</div>


<div id="org1e98c7e" class="figure">
<p><img src="../images/from_clipboard/20240731_155253.png" alt="20240731_155253.png" />
</p>
</div>

<p>
This is considered one of the more sophisticated methods despite still being just a pretty simple modification to task arithmetic. This outperforms vanilla Task Arithmetic, RegMean, Fisher Merging, and Model Soups, but obviously it doesn't really do anything different from task arithmetic if you're only merging one task vector to the base model.
</p>

<p>
Why does this work? Don't we need the little updates too, given that the gradient updates we got from training produced them? Turns out no, you really don't &#x2013; most of the difference in performance comes from the parameter changes which are really big, and literally zeroing out 80% of the task vector will usually do almost nothing to the performance.
</p>


<div id="org2f5dfb0" class="figure">
<p><img src="../images/from_clipboard/20240731_161638.png" alt="20240731_161638.png" />
</p>
</div>

<p>
So it's empirically well-motivated<sup><a id="fnr.8" class="footref" href="#fn.8" role="doc-backlink">8</a></sup> to trim out the activations which are small, leaving us a task vector which is mostly sparse and mostly does the same thing, but is less likely to cause problems with the model merge process, especially if the values would cause sign disagreements.
</p>

<p>
For sign disagreements, they pick the one with the highest total magnitude across all the models (i.e. sum of all the + values vs sum of all the - values). They "disjoint merge" means you set everything which is the wrong sign to 0, and then from there it's a normal merge<sup><a id="fnr.9" class="footref" href="#fn.9" role="doc-backlink">9</a></sup>. This seems to perform pretty well, usually outperforming other methods on most tasks, and performing worse if any of the steps are ablated (i.e. making it more similar to vanilla task arithmetic).
</p>
</div>
</div>

<div id="outline-container-orga3478e5" class="outline-2">
<h2 id="orga3478e5">(DARE) Language Models are Super Mario: Absorbing Abilities from Homologous Models as a Free Lunch</h2>
<div class="outline-text-2" id="text-orga3478e5">
<p>
This paper can be found <a href="https://arxiv.org/pdf/2311.03099">here</a>. The framing of this paper is EXTREMELY funny. Language models are Super Mario! You know, because they absorb, uh, items.
</p>

<p>
DARE is another method which zeros out small differences, it stands for Drop And REscale. This is often combined with other methods in practice. The step which most differentiates this from TIES-MERGING is this final rescaling step &#x2013; on top of dropping parameters, they also scale the remaining ones by \(1 / (1 - p)\) where \(p\) is the random drop rate. With this addition, they find they're able to drop 90-99% of the delta parameters, which means you can add lots of different vectors for very minimal cost. This paper, relative to other ones we've seen, is pretty explicitly only about language models, so it's unclear if this holds for all types of models.
</p>


<div id="org553b4ba" class="figure">
<p><img src="../images/from_clipboard/20240731_165605.png" alt="20240731_165605.png" />
</p>
</div>

<p>
This has the most unnavigable figure I've ever seen in a paper, ever. Check this out:
</p>


<div id="org0549fb8" class="figure">
<p><img src="../images/from_clipboard/20240731_165912.png" alt="20240731_165912.png" />
</p>
</div>

<p>
This tolerance depends on the size of the language model, i.e. one with a ton of parameters can withstand up to a 99% drop rate. Notably this is a <i>random</i> drop, not a top-k drop as seen in TIES-MERGE. This makes the scaling factor really important, because without the highest magnitude features (which are most likely dropped), we very likely need to scale whatever parameters are left by a large value to the task vector roughly the same magnitude.
</p>

<p>
The delta pruning operation is not very novel but the real contribution of this paper is the comparison of this random drop strategy with the more common magnitude-based pruning. They find that if you rescale the non-dropped parameters, the random drop does much better, and you can drop even more parameters than you would be able to with magnitude-based pruning. This is sort of counterintuitive, but it's seemingly because some signal actually does exist in the small activations after all.
</p>

<p>
This is definitely the most hacky of the papers so far &#x2013; there's even a whole section on if this works if you drop the entire fine-tuned parameter instead of the delta (it, uh, doesn't work). But definitely an interesting takeaway that, at least for language problems, pruning the task vectors randomly and rescaling might be a better try than pruning based on magnitude.  
</p>
</div>
</div>

<div id="outline-container-org2f3723e" class="outline-2">
<h2 id="org2f3723e">Model Breadcrumbs: Scaling Multi-Task Model Merging with Sparse Masks</h2>
<div class="outline-text-2" id="text-org2f3723e">
<p>
This paper can be found <a href="https://arxiv.org/pdf/2312.06795">here</a>.
</p>

<p>
This paper might help us answer the question of why random drop in DARE seems to work better than top k dropping in TIES-MERGING. Specifically, this method <i>masks outliers</i> in the task vectors, meaning it's like TIES-MERGING except instead of dropping the lowest k, we drop the lowest and highest k. The lowest and the highest values are both <i>outliers</i>, and it improves performance to drop them both. Otherwise, this is the same.
</p>


<div id="org7af0517" class="figure">
<p><img src="../images/from_clipboard/20240731_231314.png" alt="20240731_231314.png" />
</p>
</div>

<p>
There's not much to say past that &#x2013; it's DARES with top masking too.
</p>


<div id="org305e2cc" class="figure">
<p><img src="../images/from_clipboard/20240731_232108.png" alt="20240731_232108.png" />
</p>
</div>
</div>
</div>


<div id="outline-container-orgdbddd1a" class="outline-2">
<h2 id="orgdbddd1a">Model Stock: All we need is just a few fine-tuned models</h2>
<div class="outline-text-2" id="text-orgdbddd1a">
<p>
This paper can be found <a href="https://arxiv.org/pdf/2403.19522">here</a>.
</p>

<p>
It's model stock because it's like model soup, but you don't need to add much to get soup (?)<sup><a id="fnr.10" class="footref" href="#fn.10" role="doc-backlink">10</a></sup>. Specifically, that we can perform about the same as model soup (which trains like 24 finetunes) with just 3 models (2 finetunes and the base model).
</p>

<p>
This can be done by observing that model weights finetuned from different random seeds like on a thin shell in the weight space, and also observing that closer proximity to the center of this shell usually means better performance.
</p>

<p>
Using this, you can do some <i>math</i>. And this math lets you infer the location of the result of merging 50 models with just 3 points, based on these assumptions about the geometry of the weight space. This is a bit too dense to survive my initial skims but it's in mergekit so I'm assuming it works roughly as described. 
</p>

<p>
<a id="org0969cba"></a> 
</p>
</div>
</div>

<div id="outline-container-org3450da0" class="outline-2">
<h2 id="org3450da0">DELLA-Merging: Reducing Interference in Model Merging through Magnitude-Based Sampling</h2>
<div class="outline-text-2" id="text-org3450da0">
<p>
This paper can be found <a href="https://arxiv.org/pdf/2406.11617">here</a>.
</p>

<p>
If you are like me, and you read the DARE paper and thought "random drop seems like a stupid strategy, it seems like you'd do much better if you sampled points with a multinomial weighted by how big the magnitudes were", then I have bad news, this exact thought has been thought before, and it's this paper. It works better than DARE, so at least take comfort in your solid intuition! 
</p>


<div id="org0a1b86b" class="figure">
<p><img src="../images/from_clipboard/20240731_233451.png" alt="20240731_233451.png" />
</p>
</div>

<p>
Otherwise this is functionally identical to DARE. They generalize the rescale factor to \(\gamma\) but then they just set \(\gamma = 1 / (1 - p_i)\) the same as DARE so other than the sampling strategy it's functionally the same. This allows for the kept parameters to preferentially not be useless ones, while maintaining a similar sort of outlier supression that made DARE more effective than TIES-MERGING (and further validated by Model Breadcrumbs)
</p>
</div>
</div>

<div id="outline-container-org3120d32" class="outline-2">
<h2 id="org3120d32">Evolutionary Optimization of Model Merging Recipes</h2>
<div class="outline-text-2" id="text-org3120d32">
<p>
This paper can be found <a href="https://arxiv.org/pdf/2403.13187">here</a>. Here's their <a href="https://github.com/SakanaAI/evolutionary-model-merge">repo</a> which doesn't have the actual code for the method&#x2026;
</p>

<p>
This is <a href="https://asia.nikkei.com/Business/Technology/Artificial-intelligence/Japan-s-Sakana-AI-by-Google-alums-to-become-unicorn-in-under-a-year">Sakana AI</a>'s big offering so far, it's the basis for their "nature inspired AI" which they're using for a variety of things here and there. There's a few interesting things about this work, most notably that it seems to be possible even when there's some sort of task gap between the models (e.g. merging a Japanese LLM with a math LLM, applying it to <a href="https://sakana.ai/evo-ukiyoe/">a diffusion model for ukiyo-e colorization</a> and having it work well, etc). This offers some promise that techniques to "evolve" model merges via "natural selection" have some merit in improving the results.
</p>

<p>
The central claim of this paper is that model merging techniques are cost-effective and promising, but rely on human intuition and domain knowledge to perform well. To get around this, they do a bunch of stuff to automatically discover ths best way to combine models.
</p>

<p>
This work is extra significant because it features Cross-Domain Merging, i.e. it's a model merging technique which can merge models even if they aren't just two models trained to do the exact same thing on the same data, with minor differences (e.g. what a lot of people think makes merging work for LLMs, why there's so much focus in work thus far about multiple training runs on the same data and the same model, etc).
</p>

<p>
There are two ways models can be evolved:
</p>
<ol class="org-ol">
<li>Merging parameters, which is similar to all the work we've seen so far</li>
<li><i>Frankenmerging</i> which just randomly puts different layers from different models into one model<sup><a id="fnr.11" class="footref" href="#fn.11" role="doc-backlink">11</a></sup>. Who knows how this works, or if it's useful for non language problems.</li>
</ol>

<p>
That is: we can modify the weights, or we can modify the shape of the model, and we have several models' worth of weights and layers to work with.
</p>
</div>

<div id="outline-container-orge9c94b7" class="outline-3">
<h3 id="orge9c94b7">Merging Parameters</h3>
<div class="outline-text-3" id="text-orge9c94b7">
<p>
Merging parameters between layers is done with DARE + TIES-Merging, which is not too surprising. The configurations are optimized using "an evolutionary algorithm, such as <a href="https://en.wikipedia.org/wiki/CMA-ES">CMA-ES</a>" which I suppose means they're using some custom thing which they don't want to release.
</p>
</div>
</div>

<div id="outline-container-org0f067bb" class="outline-3">
<h3 id="org0f067bb">Merging Data Flow</h3>
<div class="outline-text-3" id="text-org0f067bb">
<p>
Basically this is the frankenmerging component, where you can add or remove layers from various models, verbatim, and stitch them together. This part is pretty similar in spirit to earlier work by David Ha <a href="https://arxiv.org/pdf/1906.04358">Weight Agnostic Neural Networks</a> where this is performed at the neuron-to-neuron level. Instead of connecting together neurons and activation functions, this step just adds one of the available transformer layers. It's likely this also uses something like CMA-ES (WANNs used NEAT, but mentions CMA-ES as a footnote being potentially better)
</p>
</div>
</div>

<div id="outline-container-orgb7b6d62" class="outline-3">
<h3 id="orgb7b6d62">Thoughts</h3>
<div class="outline-text-3" id="text-orgb7b6d62">
<p>
Like other methods for model merging, we don't have to do any training after this, the models are just usable immediately. Merging data flow is really weird &#x2013; we can merge any layer from any model, and often we seem to want to just combine random pieces of different models together. I don't think conceptually I understand how this doesn't completely destroy the output.
</p>

<p>
Maybe there's some funny space here for some sort of evolved <a href="https://arxiv.org/pdf/2406.04692">mixture-of-agents</a> work, where instead of evolving a single model we evolve a sort of community of models whose aggregate performance is better than other aggregates. I think this sort of thing might help clarify for me if there's any meaningful way to steer the frankenmodels to be meaningfully different from each other, rather than just randomly happening to work. 
</p>
</div>
</div>
</div>

<div id="outline-container-org0d438b8" class="outline-2">
<h2 id="org0d438b8">Frankenmerging</h2>
<div class="outline-text-2" id="text-org0d438b8">
<p>
Frankenmerging is really understudied, especially relative to how often it gets talked about in the community. There are a bunch of notable frankenmerges, like <a href="https://huggingface.co/alpindale/goliath-120b">Goliath-120b</a>, but there's not much published work which points us towards why this doesn't make the network explode. There's no citation in the Evolutionary Optimization paper with respect tof Frankenmerging, and it is not included at all in the <a href="https://arxiv.org/pdf/2309.15698">survey paper</a> I read on the topic, which only examines mode connectivity, alignment, weight averaging, and ensemble learning.
</p>

<p>
This section is slightly different from the section above in that it's going to be less "papers about model (franken) merging" and more "papers which help understand where and why frankenmerging might be useful".
</p>
</div>

<div id="outline-container-org6f9cd95" class="outline-3">
<h3 id="org6f9cd95">Understanding Robustness of Transformers for Image Classification</h3>
<div class="outline-text-3" id="text-org6f9cd95">
<p>
A hint for why frankenmerging works can be found in <a href="https://arxiv.org/pdf/2103.14586">this paper</a> from 2021, which looked at imagenet classification performance in ViT. Specifically, section 4 <i>Robustness to Model Perturbations</i> has two results which are of interest to us. First, that the hidden features of each transformer block, ignoring the first (few) layers, are generally highly correlated. Second, that removing transformer blocks, self-attention layers, or MLPs will only degrade performance a relatively small amount, rather than destroying performance.
</p>


<div id="org8e37d46" class="figure">
<p><img src="../images/from_clipboard/20240820_154435.png" alt="20240820_154435.png" />
</p>
</div>


<div id="org20eaac4" class="figure">
<p><img src="../images/from_clipboard/20240820_154452.png" alt="20240820_154452.png" />
</p>
</div>

<p>
There's other work which suggests that residual networks in general show a large amount of redundancy, and you can remove almost any individual layer in a residual network without hurting performance too much. Indeed that's what they found here: the network is pretty robust to these sorts of "lesions" with the notable exception of the first layer being too important to delete.
</p>

<p>
One point of interest here: this paper finds that more training data leads to increasingly harmed performance of lesions, potentially implying higher model utilization. Unclear to me if this is problem (e.g. vision) specific or meaningfully implies similar conclusions with language models.
</p>
</div>
</div>

<div id="outline-container-orgad6fbef" class="outline-3">
<h3 id="orgad6fbef">Transformer Layers as Painters</h3>
<div class="outline-text-3" id="text-orgad6fbef">
<p>
This paper can be found <a href="https://arxiv.org/pdf/2407.09298">here</a>. This is another Sakana AI work, and is likely the most directly related to frankenmerging: they show that intermediate transformer layers (i.e. not the first and last layers) are relatively uniform, and are often robust to being skipped, repeated, or reordered. They use the analogy of "an assembly line of painters" where each layer is responsible for painting something upon the canvas, and reordering the painters will often not catastrophically destroy the final image.
</p>


<div id="orgd1d479b" class="figure">
<p><img src="../images/from_clipboard/20240820_132805.png" alt="20240820_132805.png" />
</p>
</div>

<p>
Their hypothesis is that this is related to the residual connections during training, which could in theory encourage a shared representation space between layers. Standard MLPs, by comparison, do not have such properties, and reordering them is likely to end in disaster. 
</p>

<p>
They show the cosine similarity between hidden states and their results are certainly very hard to argue with: there seem to be distinct "blocks" where layers are generally very similar, which generally excludes the first and last layers. 
</p>


<div id="orga1ebf7c" class="figure">
<p><img src="../images/from_clipboard/20240820_133452.png" alt="20240820_133452.png" />
</p>
</div>

<p>
The remainder of this paper is a pretty easy read, a rapid-fire question-answer of experiments you might want to run based on the above observation:
</p>

<ul class="org-ul">
<li>Do layers "speak the same language"? Yes, the middle layers do seem to share a common representation space.</li>
<li>Are all the layers necessary? No, at least a few middle layers can be dropped without catastophic failure.</li>
<li>Are the middle layers all doing the same thing? No, sharing weights among middle layers is catastrophic, indicating the middle layers are performing different functions.</li>
<li>Does the layer order matter? Somewhat. Both randomizing and reversing the middle layer order has graceful degradation.</li>
<li>Can we run layers in parallel? Yes, except for math-heavy benchmarks.</li>
<li>Does the order matter for some tasks more than others? Yes! Math and reasoning tasks are more order dependent than "semantic" tasks.</li>
<li>Does looping help parallelized layers? Yes, with the optimal number of iterations proportional to the number of parallelized layers.</li>
<li>Which variants are the least harmful? Repeating a single layer is the worst, randomizing the layer order and looped-parallel do the least damage.</li>
</ul>

<p>
A funny downstream potential application of this paper is to use additional vram to accelerate inference of very small models; for example, running the layers of llama2-7b in parallel is about twice as fast as normal llama2-7b, but requires much more memory (since all the layers need to be run at once). There may be a very bitter lesson at the end of this approach, once you scale to a very very large model size<sup><a id="fnr.12" class="footref" href="#fn.12" role="doc-backlink">12</a></sup>. Also some hints for potential architecture improvements<sup><a id="fnr.13" class="footref" href="#fn.13" role="doc-backlink">13</a></sup>.
</p>

<p>
How do these properties help us understand frankenmerging? Well since they are residual networks, we can think of each block being some sort of "small addition to the canvas", rather than being a complete transformation of the existing representation. As a result, merging middle layers from other models is like adding "new painters" who "add a new object to the canvas". At best, it adds something useful; at worst, it adds some noise which shouldn't be such a huge cost. 
</p>


<div id="orga53312a" class="figure">
<p><img src="../images/from_clipboard/20240820_155907.png" alt="20240820_155907.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgf613f37" class="outline-3">
<h3 id="orgf613f37">SOLAR 10.7B: Scaling Large Language Models with Simple yet Effective Depth Up-Scaling</h3>
<div class="outline-text-3" id="text-orgf613f37">
<p>
Adjacent to frankenmerging is this paper on <i>Depth Upscaling</i> (DUS). This paper essentially adapts frankenmerging as the starting point for continued pretraining of a larger language model starting from a pair of smaller language models: creating a base for a bigger model by stacking layers from two models offset from one another.
</p>


<div id="org8e34407" class="figure">
<p><img src="../images/from_clipboard/20240820_145254.png" alt="20240820_145254.png" />
</p>
</div>

<p>
They reference this <a href="https://huggingface.co/Undi95/Mistral-11B-v0.1">Mistral 11B frankenmerge</a> as being the same as step 1, but they go on to continue pretraining it and show it getting good results. They mention that the initial merge has slightly worse performance than the original 7B model, but that this lost performance is recovered very fast with minimal continued pretraining<sup><a id="fnr.14" class="footref" href="#fn.14" role="doc-backlink">14</a></sup>.
</p>

<p>
There is actually a connection here to <a href="https://arxiv.org/pdf/1905.11946">efficientnet</a>, which does depth scaling in a similar way to how these frankenmerges work. I don't believe there's any assessment on the baseline performance after scaling depth like this, but before continued pretraining (why would there be), but in principle it's a similar starting point.
</p>


<div id="org357a25e" class="figure">
<p><img src="../images/from_clipboard/20240820_150549.png" alt="20240820_150549.png" />
</p>
</div>

<p>
This ends up working quite well &#x2013; this paper can be thought of as an interesting companion piece to <a href="https://arxiv.org/pdf/2212.05055">Sparse Upcycling: Training Mixture-of-Experts from Dense Checkpoints</a>, which similarly scales width via MoE rather than depth via frankenmerging.
</p>
</div>
</div>
</div>

<div id="outline-container-org85127e9" class="outline-2">
<h2 id="org85127e9">Appendix: Other Papers</h2>
<div class="outline-text-2" id="text-org85127e9">
<p>
By default, papers will be put in here as I read them, and they will remain here if they seem unimportant enough to graduate above to the level of "paper necessary to understand the model merging space".
</p>
</div>

<div id="outline-container-org30c3264" class="outline-3">
<h3 id="org30c3264">Dataless Knowledge Fusion by Merging Weights of Language Models</h3>
<div class="outline-text-3" id="text-org30c3264">
<p>
<a href="https://openreview.net/pdf?id=FCnohuR6AnM">Paper can be found here</a>. This paper from 2023 introduced <i>RegMean</i> (Regression Mean), sort of a combination of fisher merging and simple linear merging, which minimizes l2 distance to individual model predictions on the training sets.
</p>

<p>
The justification for model merging here is that we need data to do multi-task learning, we need a lot of memory to do ensembling of large models, and we need multiple rounds to do federated learning. In comparison, model merging is data and training-free, and results in a single model in a single round.
</p>

<p>
As you would expect, the underlying assumption is that the model architectures here are all identical. "Dataless" is also a bit of a misnomer here &#x2013; RegMean compared to other methods here is moreso <i>data aware</i> in the sense that it tries to find the optimal interpolation point between two models which maximizes the performance on some training data. It's called "dataless" because access to the training data used for each model is not necessary.
</p>

<p>
RegMean seems to perform quite well, but as mentioned requires you to run the models on some training data in order to find the optimal merge point.
</p>
</div>
</div>

<div id="outline-container-orgc0a56fa" class="outline-3">
<h3 id="orgc0a56fa">Reading List</h3>
<div class="outline-text-3" id="text-orgc0a56fa">
<p>
Here's papers yet to be read.
</p>

<p>
I will need to learn some Optimal Transport + Federated Learning concepts in order to properly do the next two papers justice, so they're slightly larger projects than the other papers. Unclear that they're very important for understanding the space.
</p>

<p>
<a href="https://arxiv.org/pdf/1910.05653">Model Fusion via Optimal Transport</a>
</p>

<p>
<a href="https://arxiv.org/pdf/2002.06440">Federated Learning with Matched Averaging</a>
</p>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
That is, you can match multiple filters to the same filter. More useful than strict matching because if you have e.g. 6 filters for faces in network A and 5 filters for faces in network B, it's annoying to match the left-out filter from network A to some random filter elsewhere.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Very interesting: Does seem to suggest that there are useful features left to be learned for each network. Intuitively feels like an ensemble of nearly identical networks could somehow be useful if you could somehow "trim out" the shared core between the two of them. 
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I vaguely remember some paper from a long time ago about permuting the weights of a neural network and still doing well, potentially related. Could just be making this up, though, since I can't find it now.
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Need to find an example of this, this was just something mentioned in the Sakana AI Evo-merging paper.
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
They really lean into this "soup" analogy
</p>


<div id="org5b67211" class="figure">
<p><img src="../images/from_clipboard/20240731_112528.png" alt="20240731_112528.png" />
</p>
</div></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I don't have that much to say on this paper &#x2013; it's important and gets brought up a lot, but it's mostly just a slightly more interesting averaging vs normal averaging. 
</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7" role="doc-backlink">7</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I feel like we just get worse at naming as time goes on.
</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8" role="doc-backlink">8</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I think theoretically it seems strange to me that these little values don't do anything but can't argue with a figure like that I suppose. Wonder if it's task-dependent.
</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9" role="doc-backlink">9</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Maybe worth noting: the averaging process ignores zeros, both from trimmed vectors and from sign-election. This method wouldn't be worth much if setting the values to 0 could drag the average towards 0. 
</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10" role="doc-backlink">10</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Very hungry researchers working in this field, huh
</p></div></div>

<div class="footdef"><sup><a id="fn.11" class="footnum" href="#fnr.11" role="doc-backlink">11</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
1) what 
</p></div></div>

<div class="footdef"><sup><a id="fn.12" class="footnum" href="#fnr.12" role="doc-backlink">12</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Easy to imagine an equivalent experiment run on llama-3.1-405B, where serving it with very fast inference requires even more compute than running 405B already does. Could also imagine that the frontier of acceptable latency could require much wider networks than is currently used.
</p></div></div>

<div class="footdef"><sup><a id="fn.13" class="footnum" href="#fnr.13" role="doc-backlink">13</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Mixture of Mixture of Experts? Route to parallel layers -&gt; route to experts?
</p></div></div>

<div class="footdef"><sup><a id="fn.14" class="footnum" href="#fnr.14" role="doc-backlink">14</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
This makes sense to me, since it just needs to patch the "seam" where the two connect whereupon it becomes two blocks known to perform at the original level &#x2013; from there it can find slightly new purposes for one of the two merged blocks.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<a href="#top">Back to Top</a>
</div>
</body>
</html>
